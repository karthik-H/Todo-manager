{
  "function": [
    {
      "implementation_id": "handleCreateTask_function_frontend_src_App_tsx",
      "test_cases": [
        {
          "id": "create_task_success",
          "name": "Create Task Successfully",
          "description": "Should create a new task when valid task data is provided, reload the task list, and close the TaskForm modal.",
          "type": "positive",
          "test_setup": {
            "given": "Valid taskData with title, description, priority, and due date. API is available and responds successfully.",
            "when": "handleCreateTask(taskData) is called.",
            "then": "api.createTask is called with taskData, tasks are reloaded, TaskForm modal is closed, and no alert is shown."
          },
          "implementation_id": "handleCreateTask_function_frontend_src_App_tsx"
        },
        {
          "id": "create_task_api_failure",
          "name": "API Failure When Creating Task",
          "description": "Should show an alert if the API call to create a task fails.",
          "type": "negative",
          "test_setup": {
            "given": "Valid taskData. API is unavailable or returns an error.",
            "when": "handleCreateTask(taskData) is called.",
            "then": "api.createTask is called and throws an error, tasks are not reloaded, TaskForm modal remains open, and alert 'Failed to create task' is shown."
          },
          "implementation_id": "handleCreateTask_function_frontend_src_App_tsx"
        },
        {
          "id": "create_task_missing_title",
          "name": "Create Task with Missing Title",
          "description": "Should handle missing title in taskData gracefully (either by preventing submission or showing an error).",
          "type": "negative",
          "test_setup": {
            "given": "taskData with missing or empty title field.",
            "when": "handleCreateTask(taskData) is called.",
            "then": "api.createTask is not called, tasks are not reloaded, TaskForm modal remains open, and appropriate validation error is shown."
          },
          "implementation_id": "handleCreateTask_function_frontend_src_App_tsx"
        },
        {
          "id": "create_task_minimum_fields",
          "name": "Create Task with Minimum Required Fields",
          "description": "Should create a task when only the required fields are provided (e.g., optional fields omitted).",
          "type": "positive",
          "test_setup": {
            "given": "taskData with only required fields (e.g., title and due date, description and priority omitted if optional). API responds successfully.",
            "when": "handleCreateTask(taskData) is called.",
            "then": "api.createTask is called with minimal taskData, tasks are reloaded, TaskForm modal is closed, and no alert is shown."
          },
          "implementation_id": "handleCreateTask_function_frontend_src_App_tsx"
        },
        {
          "id": "create_task_boundary_title_length",
          "name": "Create Task with Maximum Title Length",
          "description": "Should handle task creation when the title is at the maximum allowed length.",
          "type": "positive",
          "test_setup": {
            "given": "taskData with title at maximum allowed length (e.g., 255 characters). API responds successfully.",
            "when": "handleCreateTask(taskData) is called.",
            "then": "api.createTask is called with taskData, tasks are reloaded, TaskForm modal is closed, and no alert is shown."
          },
          "implementation_id": "handleCreateTask_function_frontend_src_App_tsx"
        },
        {
          "id": "create_task_invalid_due_date",
          "name": "Create Task with Invalid Due Date",
          "description": "Should handle invalid due date format in taskData gracefully.",
          "type": "negative",
          "test_setup": {
            "given": "taskData with an invalid due date (e.g., not a date string or a past date if not allowed).",
            "when": "handleCreateTask(taskData) is called.",
            "then": "api.createTask is not called, tasks are not reloaded, TaskForm modal remains open, and appropriate validation error is shown."
          },
          "implementation_id": "handleCreateTask_function_frontend_src_App_tsx"
        },
        {
          "id": "create_task_duplicate_title",
          "name": "Create Task with Duplicate Title",
          "description": "Should handle creation of a task with a title that already exists (if not allowed).",
          "type": "negative",
          "test_setup": {
            "given": "taskData with a title that matches an existing task. API returns a duplicate error.",
            "when": "handleCreateTask(taskData) is called.",
            "then": "api.createTask is called and returns an error, tasks are not reloaded, TaskForm modal remains open, and alert or validation error is shown."
          },
          "implementation_id": "handleCreateTask_function_frontend_src_App_tsx"
        },
        {
          "id": "create_task_rapid_submissions",
          "name": "Rapid Multiple Task Submissions",
          "description": "Should handle rapid consecutive submissions gracefully (e.g., prevent duplicate API calls or UI glitches).",
          "type": "negative",
          "test_setup": {
            "given": "User submits the form multiple times quickly with the same or different taskData.",
            "when": "handleCreateTask(taskData) is called multiple times in quick succession.",
            "then": "api.createTask is called only once per submission, UI remains consistent, and no duplicate tasks are created."
          },
          "implementation_id": "handleCreateTask_function_frontend_src_App_tsx"
        },
        {
          "id": "create_task_network_latency",
          "name": "Create Task with Network Latency",
          "description": "Should handle slow API response gracefully (e.g., show loading indicator, prevent duplicate submissions).",
          "type": "positive",
          "test_setup": {
            "given": "Valid taskData. API responds slowly.",
            "when": "handleCreateTask(taskData) is called.",
            "then": "UI shows loading state, duplicate submissions are prevented, and upon success, tasks are reloaded and TaskForm modal is closed."
          },
          "implementation_id": "handleCreateTask_function_frontend_src_App_tsx"
        },
        {
          "id": "create_task_modal_closure_on_success",
          "name": "TaskForm Modal Closes on Success",
          "description": "Should close the TaskForm modal only after successful task creation.",
          "type": "positive",
          "test_setup": {
            "given": "Valid taskData. API responds successfully.",
            "when": "handleCreateTask(taskData) is called.",
            "then": "TaskForm modal is closed only after api.createTask resolves and tasks are reloaded."
          },
          "implementation_id": "handleCreateTask_function_frontend_src_App_tsx"
        }
      ]
    },
    {
      "implementation_id": "api_createTask_function_frontend_src_api_ts",
      "test_cases": [
        {
          "id": "create_task_success_all_fields",
          "name": "Create task with all valid fields",
          "description": "Should successfully create a new task when all required fields (title, description, priority, due date) are provided and valid.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task object with title, description, priority, and due date.",
            "when": "api.createTask is called with this object.",
            "then": "The function returns the created task as received from the backend."
          },
          "implementation_id": "api_createTask_function_frontend_src_api_ts"
        },
        {
          "id": "create_task_missing_optional_description",
          "name": "Create task with missing optional description",
          "description": "Should successfully create a new task when the description field is omitted (if description is optional).",
          "type": "positive",
          "test_setup": {
            "given": "A valid task object with title, priority, and due date, but no description.",
            "when": "api.createTask is called with this object.",
            "then": "The function returns the created task as received from the backend."
          },
          "implementation_id": "api_createTask_function_frontend_src_api_ts"
        },
        {
          "id": "create_task_minimum_title_length",
          "name": "Create task with minimum title length",
          "description": "Should successfully create a new task when the title is at the minimum allowed length.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with a title of minimum allowed length, valid description, priority, and due date.",
            "when": "api.createTask is called.",
            "then": "The function returns the created task as received from the backend."
          },
          "implementation_id": "api_createTask_function_frontend_src_api_ts"
        },
        {
          "id": "create_task_maximum_title_length",
          "name": "Create task with maximum title length",
          "description": "Should successfully create a new task when the title is at the maximum allowed length.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with a title of maximum allowed length, valid description, priority, and due date.",
            "when": "api.createTask is called.",
            "then": "The function returns the created task as received from the backend."
          },
          "implementation_id": "api_createTask_function_frontend_src_api_ts"
        },
        {
          "id": "create_task_invalid_priority",
          "name": "Create task with invalid priority value",
          "description": "Should throw an error if the priority value is not accepted by the backend.",
          "type": "negative",
          "test_setup": {
            "given": "A task object with an invalid priority value (e.g., not in allowed set).",
            "when": "api.createTask is called.",
            "then": "The function throws an error due to backend response not being OK."
          },
          "implementation_id": "api_createTask_function_frontend_src_api_ts"
        },
        {
          "id": "create_task_missing_title",
          "name": "Create task with missing title",
          "description": "Should throw an error if the title field is missing.",
          "type": "negative",
          "test_setup": {
            "given": "A task object missing the title field.",
            "when": "api.createTask is called.",
            "then": "The function throws an error due to backend response not being OK."
          },
          "implementation_id": "api_createTask_function_frontend_src_api_ts"
        },
        {
          "id": "create_task_empty_title",
          "name": "Create task with empty title",
          "description": "Should throw an error if the title field is empty.",
          "type": "negative",
          "test_setup": {
            "given": "A task object with an empty string as the title.",
            "when": "api.createTask is called.",
            "then": "The function throws an error due to backend response not being OK."
          },
          "implementation_id": "api_createTask_function_frontend_src_api_ts"
        },
        {
          "id": "create_task_past_due_date",
          "name": "Create task with past due date",
          "description": "Should throw an error if the due date is in the past.",
          "type": "negative",
          "test_setup": {
            "given": "A task object with a due date set in the past.",
            "when": "api.createTask is called.",
            "then": "The function throws an error due to backend response not being OK."
          },
          "implementation_id": "api_createTask_function_frontend_src_api_ts"
        },
        {
          "id": "create_task_backend_error",
          "name": "Create task when backend returns error",
          "description": "Should throw an error if the backend returns a non-OK response (e.g., 500 Internal Server Error).",
          "type": "negative",
          "test_setup": {
            "given": "A valid task object, but the backend is configured to return an error.",
            "when": "api.createTask is called.",
            "then": "The function throws an error due to backend response not being OK."
          },
          "implementation_id": "api_createTask_function_frontend_src_api_ts"
        },
        {
          "id": "create_task_network_failure",
          "name": "Create task with network failure",
          "description": "Should throw an error if the network request fails (e.g., network is down).",
          "type": "negative",
          "test_setup": {
            "given": "A valid task object, but the network is unavailable.",
            "when": "api.createTask is called.",
            "then": "The function throws an error due to network failure."
          },
          "implementation_id": "api_createTask_function_frontend_src_api_ts"
        },
        {
          "id": "create_task_large_description",
          "name": "Create task with very large description",
          "description": "Should handle a task with a very large description field (boundary test for description length).",
          "type": "positive",
          "test_setup": {
            "given": "A task object with a very large description string, valid title, priority, and due date.",
            "when": "api.createTask is called.",
            "then": "The function returns the created task as received from the backend, or throws an error if backend rejects large descriptions."
          },
          "implementation_id": "api_createTask_function_frontend_src_api_ts"
        },
        {
          "id": "create_task_invalid_due_date_format",
          "name": "Create task with invalid due date format",
          "description": "Should throw an error if the due date is not in a valid date format.",
          "type": "negative",
          "test_setup": {
            "given": "A task object with an invalid due date format (e.g., 'not-a-date').",
            "when": "api.createTask is called.",
            "then": "The function throws an error due to backend response not being OK."
          },
          "implementation_id": "api_createTask_function_frontend_src_api_ts"
        },
        {
          "id": "create_task_duplicate_title",
          "name": "Create task with duplicate title",
          "description": "Should handle creation of a task with a title that already exists (if uniqueness is enforced).",
          "type": "negative",
          "test_setup": {
            "given": "A task object with a title that already exists in the backend.",
            "when": "api.createTask is called.",
            "then": "The function throws an error due to backend response not being OK, or returns the created task if duplicates are allowed."
          },
          "implementation_id": "api_createTask_function_frontend_src_api_ts"
        }
      ]
    },
    {
      "implementation_id": "add_task_function_backend_database_py",
      "test_cases": [
        {
          "id": "add_task_valid_input",
          "name": "test_add_task_with_valid_input",
          "description": "Verify that add_task successfully creates and returns a new Task when provided with valid input.",
          "type": "positive",
          "test_setup": {
            "given": "A valid TaskCreate object with title, description, priority, and due date. The tasks list is initially empty or contains existing tasks.",
            "when": "add_task is called with the valid TaskCreate object.",
            "then": "A new Task object with a unique ID and matching fields is returned. The task is appended to the persistent storage."
          },
          "implementation_id": "add_task_function_backend_database_py"
        },
        {
          "id": "add_task_unique_id",
          "name": "test_add_task_assigns_unique_id",
          "description": "Ensure that each new task receives a unique ID, even if other fields are identical.",
          "type": "positive",
          "test_setup": {
            "given": "A TaskCreate object is used to add multiple tasks with identical fields.",
            "when": "add_task is called multiple times with the same input.",
            "then": "Each returned Task has a unique ID, and all are present in persistent storage."
          },
          "implementation_id": "add_task_function_backend_database_py"
        },
        {
          "id": "add_task_persistent_storage_update",
          "name": "test_add_task_updates_persistent_storage",
          "description": "Verify that the persistent storage is updated after adding a new task.",
          "type": "positive",
          "test_setup": {
            "given": "A valid TaskCreate object and a known initial state of persistent storage.",
            "when": "add_task is called.",
            "then": "The new task is present in the persistent storage after the function returns."
          },
          "implementation_id": "add_task_function_backend_database_py"
        },
        {
          "id": "add_task_minimal_fields",
          "name": "test_add_task_with_minimal_fields",
          "description": "Test adding a task with only required fields (if some fields are optional).",
          "type": "positive",
          "test_setup": {
            "given": "A TaskCreate object with only required fields populated.",
            "when": "add_task is called.",
            "then": "A new Task is created with default values for missing optional fields."
          },
          "implementation_id": "add_task_function_backend_database_py"
        },
        {
          "id": "add_task_empty_title",
          "name": "test_add_task_with_empty_title",
          "description": "Test behavior when the title field is empty.",
          "type": "negative",
          "test_setup": {
            "given": "A TaskCreate object with an empty title.",
            "when": "add_task is called.",
            "then": "An error is raised or the task is not created, depending on validation rules."
          },
          "implementation_id": "add_task_function_backend_database_py"
        },
        {
          "id": "add_task_invalid_priority",
          "name": "test_add_task_with_invalid_priority",
          "description": "Test behavior when the priority field is outside the allowed range or invalid.",
          "type": "negative",
          "test_setup": {
            "given": "A TaskCreate object with an invalid priority value (e.g., negative or too high).",
            "when": "add_task is called.",
            "then": "An error is raised or the task is not created, depending on validation rules."
          },
          "implementation_id": "add_task_function_backend_database_py"
        },
        {
          "id": "add_task_past_due_date",
          "name": "test_add_task_with_past_due_date",
          "description": "Test behavior when the due date is in the past.",
          "type": "negative",
          "test_setup": {
            "given": "A TaskCreate object with a due date set in the past.",
            "when": "add_task is called.",
            "then": "An error is raised or the task is not created, depending on validation rules."
          },
          "implementation_id": "add_task_function_backend_database_py"
        },
        {
          "id": "add_task_storage_failure",
          "name": "test_add_task_storage_failure",
          "description": "Simulate a failure when saving to persistent storage (e.g., file write error).",
          "type": "negative",
          "test_setup": {
            "given": "A valid TaskCreate object and persistent storage is unavailable or read-only.",
            "when": "add_task is called.",
            "then": "An error is raised and the new task is not added to the in-memory list."
          },
          "implementation_id": "add_task_function_backend_database_py"
        },
        {
          "id": "add_task_large_number_of_tasks",
          "name": "test_add_task_with_large_number_of_existing_tasks",
          "description": "Test adding a task when the tasks list is very large to check for performance or ID collision issues.",
          "type": "positive",
          "test_setup": {
            "given": "Persistent storage contains a large number of tasks.",
            "when": "add_task is called with a valid TaskCreate object.",
            "then": "A new Task with a unique ID is created and added without performance degradation or ID collision."
          },
          "implementation_id": "add_task_function_backend_database_py"
        },
        {
          "id": "add_task_special_characters",
          "name": "test_add_task_with_special_characters",
          "description": "Test adding a task with special characters in the title and description.",
          "type": "positive",
          "test_setup": {
            "given": "A TaskCreate object with special characters in the title and description.",
            "when": "add_task is called.",
            "then": "A new Task is created with the special characters preserved."
          },
          "implementation_id": "add_task_function_backend_database_py"
        },
        {
          "id": "add_task_duplicate_title",
          "name": "test_add_task_with_duplicate_title",
          "description": "Test adding a task with a title that already exists in another task.",
          "type": "positive",
          "test_setup": {
            "given": "A TaskCreate object with a title matching an existing task.",
            "when": "add_task is called.",
            "then": "A new Task is created with a unique ID, even if the title is not unique."
          },
          "implementation_id": "add_task_function_backend_database_py"
        },
        {
          "id": "add_task_missing_required_field",
          "name": "test_add_task_missing_required_field",
          "description": "Test behavior when a required field is missing from the input.",
          "type": "negative",
          "test_setup": {
            "given": "A TaskCreate object missing a required field (e.g., title or due date).",
            "when": "add_task is called.",
            "then": "An error is raised and the task is not created."
          },
          "implementation_id": "add_task_function_backend_database_py"
        }
      ]
    },
    {
      "implementation_id": "App_openEdit_function",
      "test_cases": [
        {
          "id": "openedit_positive_valid_task",
          "name": "openEdit sets editingTask and opens form for valid task",
          "description": "Verifies that openEdit correctly sets the editingTask and opens the TaskForm modal when provided with a valid task object.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task object is passed to openEdit, editingTask is null, and isFormOpen is false.",
            "when": "openEdit(task) is called.",
            "then": "editingTask is set to the provided task, and isFormOpen is true."
          },
          "implementation_id": "App_openEdit_function"
        },
        {
          "id": "openedit_positive_overwrite_existing_editingtask",
          "name": "openEdit overwrites existing editingTask",
          "description": "Checks that openEdit replaces the current editingTask with a new task and opens the TaskForm modal.",
          "type": "positive",
          "test_setup": {
            "given": "editingTask is already set to a different task, isFormOpen is false, and a new valid task is provided.",
            "when": "openEdit(newTask) is called.",
            "then": "editingTask is updated to newTask, and isFormOpen is true."
          },
          "implementation_id": "App_openEdit_function"
        },
        {
          "id": "openedit_positive_form_already_open",
          "name": "openEdit sets editingTask when form is already open",
          "description": "Ensures that openEdit updates the editingTask even if the TaskForm modal is already open.",
          "type": "positive",
          "test_setup": {
            "given": "isFormOpen is already true, editingTask is set to a different task, and a new valid task is provided.",
            "when": "openEdit(newTask) is called.",
            "then": "editingTask is updated to newTask, and isFormOpen remains true."
          },
          "implementation_id": "App_openEdit_function"
        },
        {
          "id": "openedit_negative_null_task",
          "name": "openEdit called with null task",
          "description": "Tests the behavior when openEdit is called with a null task.",
          "type": "negative",
          "test_setup": {
            "given": "editingTask is null, isFormOpen is false, and null is passed as the task.",
            "when": "openEdit(null) is called.",
            "then": "editingTask is set to null, isFormOpen is true, or an error is thrown/logged depending on implementation."
          },
          "implementation_id": "App_openEdit_function"
        },
        {
          "id": "openedit_negative_undefined_task",
          "name": "openEdit called with undefined task",
          "description": "Tests the behavior when openEdit is called with undefined as the task.",
          "type": "negative",
          "test_setup": {
            "given": "editingTask is null, isFormOpen is false, and undefined is passed as the task.",
            "when": "openEdit(undefined) is called.",
            "then": "editingTask is set to undefined, isFormOpen is true, or an error is thrown/logged depending on implementation."
          },
          "implementation_id": "App_openEdit_function"
        },
        {
          "id": "openedit_negative_invalid_task_object",
          "name": "openEdit called with invalid task object",
          "description": "Tests the behavior when openEdit is called with an invalid task object (e.g., missing required fields).",
          "type": "negative",
          "test_setup": {
            "given": "editingTask is null, isFormOpen is false, and an invalid task object is passed.",
            "when": "openEdit(invalidTask) is called.",
            "then": "editingTask is set to invalidTask, isFormOpen is true, or an error is thrown/logged depending on implementation."
          },
          "implementation_id": "App_openEdit_function"
        },
        {
          "id": "openedit_positive_idempotent_call",
          "name": "openEdit called with same task as current editingTask",
          "description": "Checks that calling openEdit with the same task as the current editingTask still opens the TaskForm modal.",
          "type": "positive",
          "test_setup": {
            "given": "editingTask is already set to taskA, isFormOpen is false.",
            "when": "openEdit(taskA) is called.",
            "then": "editingTask remains taskA, and isFormOpen is true."
          },
          "implementation_id": "App_openEdit_function"
        },
        {
          "id": "openedit_negative_nonobject_task",
          "name": "openEdit called with non-object task (e.g., string, number)",
          "description": "Tests the behavior when openEdit is called with a non-object value as the task.",
          "type": "negative",
          "test_setup": {
            "given": "editingTask is null, isFormOpen is false, and a non-object value (e.g., string or number) is passed.",
            "when": "openEdit('notAnObject') or openEdit(123) is called.",
            "then": "editingTask is set to the non-object value, isFormOpen is true, or an error is thrown/logged depending on implementation."
          },
          "implementation_id": "App_openEdit_function"
        }
      ]
    },
    {
      "implementation_id": "App_handleUpdateTask_function",
      "test_cases": [
        {
          "id": "update_task_success",
          "name": "Update Task Successfully",
          "description": "Should update an existing task when valid data is provided and editingTask is set.",
          "type": "positive",
          "test_setup": {
            "given": "editingTask is set to a valid task object; taskData contains valid updated fields.",
            "when": "handleUpdateTask(taskData) is called.",
            "then": "api.updateTask is called with correct id and data; tasks are reloaded; editingTask is cleared; form is closed; no error alert is shown."
          },
          "implementation_id": "App_handleUpdateTask_function"
        },
        {
          "id": "no_editing_task",
          "name": "No Editing Task Set",
          "description": "Should not attempt to update if editingTask is null.",
          "type": "negative",
          "test_setup": {
            "given": "editingTask is null; taskData contains valid data.",
            "when": "handleUpdateTask(taskData) is called.",
            "then": "api.updateTask is not called; tasks are not reloaded; editingTask remains null; form remains unchanged; no error alert is shown."
          },
          "implementation_id": "App_handleUpdateTask_function"
        },
        {
          "id": "api_update_failure",
          "name": "API Update Fails",
          "description": "Should show an error alert if the API call to update the task fails.",
          "type": "negative",
          "test_setup": {
            "given": "editingTask is set to a valid task object; taskData contains valid data; api.updateTask throws an error.",
            "when": "handleUpdateTask(taskData) is called.",
            "then": "Error alert is shown; tasks are not reloaded; editingTask is not cleared; form is not closed."
          },
          "implementation_id": "App_handleUpdateTask_function"
        },
        {
          "id": "empty_task_data",
          "name": "Empty Task Data",
          "description": "Should handle empty or minimal taskData gracefully.",
          "type": "negative",
          "test_setup": {
            "given": "editingTask is set to a valid task object; taskData is empty or missing required fields.",
            "when": "handleUpdateTask(taskData) is called.",
            "then": "api.updateTask may throw an error or reject; error alert is shown; tasks are not reloaded; editingTask is not cleared; form is not closed."
          },
          "implementation_id": "App_handleUpdateTask_function"
        },
        {
          "id": "boundary_task_data",
          "name": "Boundary Task Data",
          "description": "Should update the task when taskData contains boundary values (e.g., max/min length strings).",
          "type": "positive",
          "test_setup": {
            "given": "editingTask is set to a valid task object; taskData contains fields with boundary values (e.g., max allowed title length).",
            "when": "handleUpdateTask(taskData) is called.",
            "then": "api.updateTask is called with boundary values; tasks are reloaded; editingTask is cleared; form is closed; no error alert is shown."
          },
          "implementation_id": "App_handleUpdateTask_function"
        },
        {
          "id": "api_returns_unexpected_response",
          "name": "API Returns Unexpected Response",
          "description": "Should handle unexpected API responses gracefully.",
          "type": "negative",
          "test_setup": {
            "given": "editingTask is set; api.updateTask returns an unexpected response (e.g., missing fields, malformed data).",
            "when": "handleUpdateTask(taskData) is called.",
            "then": "Error alert is shown or handled gracefully; tasks may not be reloaded; editingTask may not be cleared; form may not be closed."
          },
          "implementation_id": "App_handleUpdateTask_function"
        },
        {
          "id": "form_closure_after_update",
          "name": "Form Closes After Successful Update",
          "description": "Should close the form after a successful update.",
          "type": "positive",
          "test_setup": {
            "given": "editingTask is set; api.updateTask succeeds.",
            "when": "handleUpdateTask(taskData) is called.",
            "then": "Form is closed after update; editingTask is cleared."
          },
          "implementation_id": "App_handleUpdateTask_function"
        },
        {
          "id": "concurrent_update_attempts",
          "name": "Concurrent Update Attempts",
          "description": "Should handle multiple rapid submissions gracefully (e.g., debounce or ignore while updating).",
          "type": "negative",
          "test_setup": {
            "given": "editingTask is set; user submits the form multiple times rapidly.",
            "when": "handleUpdateTask(taskData) is called multiple times in quick succession.",
            "then": "api.updateTask is not called concurrently; only one update is processed; UI remains consistent."
          },
          "implementation_id": "App_handleUpdateTask_function"
        }
      ]
    },
    {
      "implementation_id": "api_updateTask_function",
      "test_cases": [
        {
          "id": "updateTask_valid_update",
          "name": "Update task with valid data",
          "description": "Should successfully update a task when provided with a valid ID and valid task data.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task ID and a valid task object with updated fields.",
            "when": "api.updateTask(id, task) is called.",
            "then": "The function returns the updated task as received from the backend."
          },
          "implementation_id": "api_updateTask_function"
        },
        {
          "id": "updateTask_toggle_completion",
          "name": "Toggle task completion status",
          "description": "Should update the completion status of a task and persist the change.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task ID and a task object with the 'completed' field toggled.",
            "when": "api.updateTask(id, task) is called.",
            "then": "The function returns the task with the updated completion status."
          },
          "implementation_id": "api_updateTask_function"
        },
        {
          "id": "updateTask_persist_after_refresh",
          "name": "Persist updated task after page refresh",
          "description": "Should ensure that the updated task data persists after a page refresh.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task ID and updated task data, with the backend/database configured to persist changes.",
            "when": "api.updateTask(id, task) is called and the page is refreshed.",
            "then": "The updated task data is still present after the refresh."
          },
          "implementation_id": "api_updateTask_function"
        },
        {
          "id": "updateTask_invalid_id",
          "name": "Update task with invalid ID",
          "description": "Should throw an error when attempting to update a task with an invalid or non-existent ID.",
          "type": "negative",
          "test_setup": {
            "given": "An invalid or non-existent task ID and a valid task object.",
            "when": "api.updateTask(id, task) is called.",
            "then": "The function throws an error indicating the task was not found."
          },
          "implementation_id": "api_updateTask_function"
        },
        {
          "id": "updateTask_invalid_task_data",
          "name": "Update task with invalid data",
          "description": "Should throw an error when provided with invalid task data (e.g., missing required fields).",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and an invalid task object (e.g., missing 'title' or required fields).",
            "when": "api.updateTask(id, task) is called.",
            "then": "The function throws an error indicating invalid input."
          },
          "implementation_id": "api_updateTask_function"
        },
        {
          "id": "updateTask_backend_error",
          "name": "Backend returns error",
          "description": "Should throw an error if the backend responds with an error (e.g., 500 Internal Server Error).",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and valid task data, but the backend is configured to return an error.",
            "when": "api.updateTask(id, task) is called.",
            "then": "The function throws an error with the backend's error message."
          },
          "implementation_id": "api_updateTask_function"
        },
        {
          "id": "updateTask_network_failure",
          "name": "Network failure during update",
          "description": "Should throw an error if there is a network failure during the update request.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and valid task data, but the network connection is interrupted.",
            "when": "api.updateTask(id, task) is called.",
            "then": "The function throws a network error."
          },
          "implementation_id": "api_updateTask_function"
        },
        {
          "id": "updateTask_empty_task_object",
          "name": "Update with empty task object",
          "description": "Should throw an error when attempting to update a task with an empty object.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and an empty task object ({}).",
            "when": "api.updateTask(id, task) is called.",
            "then": "The function throws an error indicating invalid input."
          },
          "implementation_id": "api_updateTask_function"
        },
        {
          "id": "updateTask_large_task_data",
          "name": "Update with large task data",
          "description": "Should handle updating a task with a very large payload (e.g., long description or title).",
          "type": "positive",
          "test_setup": {
            "given": "A valid task ID and a task object with very large string fields.",
            "when": "api.updateTask(id, task) is called.",
            "then": "The function returns the updated task if the backend accepts the payload, or throws an error if the payload is too large."
          },
          "implementation_id": "api_updateTask_function"
        },
        {
          "id": "updateTask_id_as_null_or_undefined",
          "name": "Update with null or undefined ID",
          "description": "Should throw an error when the task ID is null or undefined.",
          "type": "negative",
          "test_setup": {
            "given": "A null or undefined task ID and a valid task object.",
            "when": "api.updateTask(id, task) is called.",
            "then": "The function throws an error indicating the ID is invalid."
          },
          "implementation_id": "api_updateTask_function"
        }
      ]
    },
    {
      "implementation_id": "TaskItem_handleDelete",
      "test_cases": [
        {
          "id": "delete_confirmed_calls_onDelete",
          "name": "Delete confirmed calls onDelete",
          "description": "When the user confirms the deletion in the confirmation prompt, the onDelete prop should be called with the correct task id.",
          "type": "positive",
          "test_setup": {
            "given": "A TaskItem component with a valid task and a mock onDelete function. window.confirm is mocked to return true.",
            "when": "handleDelete is called.",
            "then": "onDelete is called once with the task id."
          },
          "implementation_id": "TaskItem_handleDelete"
        },
        {
          "id": "delete_cancelled_does_not_call_onDelete",
          "name": "Delete cancelled does not call onDelete",
          "description": "When the user cancels the deletion in the confirmation prompt, the onDelete prop should not be called.",
          "type": "negative",
          "test_setup": {
            "given": "A TaskItem component with a valid task and a mock onDelete function. window.confirm is mocked to return false.",
            "when": "handleDelete is called.",
            "then": "onDelete is not called."
          },
          "implementation_id": "TaskItem_handleDelete"
        },
        {
          "id": "delete_with_invalid_task_id",
          "name": "Delete with invalid task id",
          "description": "If the task id is undefined or null, and the user confirms deletion, onDelete should be called with the invalid id (edge case).",
          "type": "negative",
          "test_setup": {
            "given": "A TaskItem component with task.id set to undefined or null, and a mock onDelete function. window.confirm is mocked to return true.",
            "when": "handleDelete is called.",
            "then": "onDelete is called with undefined or null as the argument."
          },
          "implementation_id": "TaskItem_handleDelete"
        },
        {
          "id": "delete_with_onDelete_not_function",
          "name": "Delete with onDelete not a function",
          "description": "If the onDelete prop is not a function, and the user confirms deletion, the function should handle the error gracefully (error scenario).",
          "type": "negative",
          "test_setup": {
            "given": "A TaskItem component with onDelete set to undefined or a non-function value. window.confirm is mocked to return true.",
            "when": "handleDelete is called.",
            "then": "No exception is thrown, or an error is logged as appropriate."
          },
          "implementation_id": "TaskItem_handleDelete"
        },
        {
          "id": "delete_with_window_confirm_throws",
          "name": "Delete with window.confirm throwing error",
          "description": "If window.confirm throws an error (e.g., due to browser restrictions), the function should not call onDelete and should handle the error gracefully.",
          "type": "negative",
          "test_setup": {
            "given": "A TaskItem component with a valid task and a mock onDelete function. window.confirm is mocked to throw an error.",
            "when": "handleDelete is called.",
            "then": "onDelete is not called, and the error is handled gracefully."
          },
          "implementation_id": "TaskItem_handleDelete"
        },
        {
          "id": "delete_multiple_calls_confirmed",
          "name": "Multiple delete calls with confirmation",
          "description": "If handleDelete is called multiple times and the user confirms each time, onDelete should be called each time with the correct task id.",
          "type": "positive",
          "test_setup": {
            "given": "A TaskItem component with a valid task and a mock onDelete function. window.confirm is mocked to return true.",
            "when": "handleDelete is called multiple times.",
            "then": "onDelete is called the same number of times as handleDelete, each with the task id."
          },
          "implementation_id": "TaskItem_handleDelete"
        },
        {
          "id": "delete_multiple_calls_cancelled",
          "name": "Multiple delete calls with cancellation",
          "description": "If handleDelete is called multiple times and the user cancels each time, onDelete should never be called.",
          "type": "negative",
          "test_setup": {
            "given": "A TaskItem component with a valid task and a mock onDelete function. window.confirm is mocked to return false.",
            "when": "handleDelete is called multiple times.",
            "then": "onDelete is never called."
          },
          "implementation_id": "TaskItem_handleDelete"
        }
      ]
    },
    {
      "implementation_id": "App_handleDeleteTask",
      "test_cases": [
        {
          "id": "delete_task_success",
          "name": "Delete Task Successfully",
          "description": "Should call the API to delete the task and update the local state to remove the task when deletion succeeds.",
          "type": "positive",
          "test_setup": {
            "given": "A list of tasks exists in state. The API deleteTask method resolves successfully for the given task ID.",
            "when": "handleDeleteTask is called with a valid task ID.",
            "then": "The API deleteTask method is called with the correct ID, and the task is removed from the local state."
          },
          "implementation_id": "App_handleDeleteTask"
        },
        {
          "id": "delete_task_api_failure",
          "name": "Delete Task API Failure",
          "description": "Should alert the user and not update the local state if the API call to delete the task fails.",
          "type": "negative",
          "test_setup": {
            "given": "A list of tasks exists in state. The API deleteTask method rejects with an error.",
            "when": "handleDeleteTask is called with a valid task ID.",
            "then": "An alert with the message 'Failed to delete task' is shown, and the local state remains unchanged."
          },
          "implementation_id": "App_handleDeleteTask"
        },
        {
          "id": "delete_task_nonexistent_id",
          "name": "Delete Nonexistent Task",
          "description": "Should handle gracefully when attempting to delete a task ID that does not exist in the local state.",
          "type": "negative",
          "test_setup": {
            "given": "A list of tasks exists in state. The API deleteTask method resolves successfully, but the provided ID does not exist in the local state.",
            "when": "handleDeleteTask is called with a nonexistent task ID.",
            "then": "The API deleteTask method is called with the given ID, and the local state remains unchanged (no error is thrown)."
          },
          "implementation_id": "App_handleDeleteTask"
        },
        {
          "id": "delete_task_empty_list",
          "name": "Delete Task from Empty List",
          "description": "Should handle gracefully when attempting to delete a task from an empty task list.",
          "type": "negative",
          "test_setup": {
            "given": "The local state contains an empty task list. The API deleteTask method resolves successfully.",
            "when": "handleDeleteTask is called with any task ID.",
            "then": "The API deleteTask method is called with the given ID, and the local state remains an empty list (no error is thrown)."
          },
          "implementation_id": "App_handleDeleteTask"
        },
        {
          "id": "delete_task_invalid_id_type",
          "name": "Delete Task with Invalid ID Type",
          "description": "Should handle gracefully when called with an invalid ID type (e.g., null, undefined, or non-string/number).",
          "type": "negative",
          "test_setup": {
            "given": "A list of tasks exists in state. The API deleteTask method rejects or throws an error due to invalid ID type.",
            "when": "handleDeleteTask is called with an invalid ID (e.g., null, undefined, object).",
            "then": "An alert with the message 'Failed to delete task' is shown, and the local state remains unchanged."
          },
          "implementation_id": "App_handleDeleteTask"
        },
        {
          "id": "delete_task_multiple_calls",
          "name": "Delete Multiple Tasks Sequentially",
          "description": "Should correctly update the local state when deleting multiple tasks one after another.",
          "type": "positive",
          "test_setup": {
            "given": "A list of multiple tasks exists in state. The API deleteTask method resolves successfully for each call.",
            "when": "handleDeleteTask is called sequentially with different valid task IDs.",
            "then": "Each task is removed from the local state after its respective call, and the API is called with the correct IDs."
          },
          "implementation_id": "App_handleDeleteTask"
        },
        {
          "id": "delete_task_api_slow_response",
          "name": "Delete Task with Slow API Response",
          "description": "Should not update the local state until the API deleteTask call resolves, even if the response is delayed.",
          "type": "positive",
          "test_setup": {
            "given": "A list of tasks exists in state. The API deleteTask method returns a promise that resolves after a delay.",
            "when": "handleDeleteTask is called with a valid task ID.",
            "then": "The local state is only updated to remove the task after the API call resolves, not before."
          },
          "implementation_id": "App_handleDeleteTask"
        }
      ]
    },
    {
      "implementation_id": "App_handleToggleComplete",
      "test_cases": [
        {
          "id": "toggle_complete_success",
          "name": "Toggle task completion status successfully",
          "description": "Should toggle the completed status of a task and reload the task list when the API call succeeds.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with completed: false and a working api.updateTask implementation.",
            "when": "handleToggleComplete(task) is called.",
            "then": "api.updateTask is called with completed: true, and the task list is reloaded."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_pending_success",
          "name": "Toggle task pending status successfully",
          "description": "Should toggle the completed status of a completed task back to pending and reload the task list when the API call succeeds.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with completed: true and a working api.updateTask implementation.",
            "when": "handleToggleComplete(task) is called.",
            "then": "api.updateTask is called with completed: false, and the task list is reloaded."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_api_failure",
          "name": "API failure when toggling task status",
          "description": "Should show an alert with 'Failed to update task status' if the API call fails.",
          "type": "negative",
          "test_setup": {
            "given": "A task object and api.updateTask throws an error.",
            "when": "handleToggleComplete(task) is called.",
            "then": "An alert with the message 'Failed to update task status' is shown, and the task list is not reloaded."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_null_task",
          "name": "Null task input",
          "description": "Should handle being called with a null or undefined task gracefully.",
          "type": "negative",
          "test_setup": {
            "given": "A null or undefined task object.",
            "when": "handleToggleComplete(task) is called.",
            "then": "An error is caught and an alert with 'Failed to update task status' is shown."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_missing_id",
          "name": "Task with missing id",
          "description": "Should handle a task object missing the id property.",
          "type": "negative",
          "test_setup": {
            "given": "A task object without an id property.",
            "when": "handleToggleComplete(task) is called.",
            "then": "An error is caught and an alert with 'Failed to update task status' is shown."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_missing_completed",
          "name": "Task with missing completed property",
          "description": "Should treat missing completed property as false and toggle to true.",
          "type": "positive",
          "test_setup": {
            "given": "A task object without a completed property.",
            "when": "handleToggleComplete(task) is called.",
            "then": "api.updateTask is called with completed: true, and the task list is reloaded."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_api_slow_response",
          "name": "API slow response",
          "description": "Should wait for the API call to complete before reloading the task list.",
          "type": "positive",
          "test_setup": {
            "given": "A task object and api.updateTask returns a promise that resolves after a delay.",
            "when": "handleToggleComplete(task) is called.",
            "then": "The task list is reloaded only after the API call resolves."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_multiple_calls",
          "name": "Multiple rapid toggles",
          "description": "Should handle multiple rapid calls to handleToggleComplete without inconsistent state.",
          "type": "negative",
          "test_setup": {
            "given": "A task object and api.updateTask implementation.",
            "when": "handleToggleComplete(task) is called multiple times rapidly.",
            "then": "Each call toggles the completed status and reloads the task list after each API call."
          },
          "implementation_id": "App_handleToggleComplete"
        }
      ]
    },
    {
      "implementation_id": "api_updateTask",
      "test_cases": [
        {
          "id": "updateTask_successful_update_completed_true",
          "name": "Successful update of task to completed",
          "description": "Should successfully update a task's completed status to true and return the updated task.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task ID and a task object with completed: true. Backend is available and responds with 200 OK and updated task data.",
            "when": "api.updateTask(id, { ...task, completed: true }) is called",
            "then": "Returns the updated task object with completed: true"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "updateTask_successful_update_completed_false",
          "name": "Successful update of task to pending",
          "description": "Should successfully update a task's completed status to false and return the updated task.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task ID and a task object with completed: false. Backend is available and responds with 200 OK and updated task data.",
            "when": "api.updateTask(id, { ...task, completed: false }) is called",
            "then": "Returns the updated task object with completed: false"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "updateTask_invalid_id",
          "name": "Update with invalid task ID",
          "description": "Should throw an error if the task ID does not exist (backend returns 404).",
          "type": "negative",
          "test_setup": {
            "given": "An invalid/non-existent task ID and a valid task object. Backend responds with 404 Not Found.",
            "when": "api.updateTask(invalidId, task) is called",
            "then": "Throws an error indicating the task was not found"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "updateTask_backend_error",
          "name": "Backend error during update",
          "description": "Should throw an error if the backend returns a 500 Internal Server Error.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and task object. Backend responds with 500 Internal Server Error.",
            "when": "api.updateTask(id, task) is called",
            "then": "Throws an error indicating a server error occurred"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "updateTask_network_failure",
          "name": "Network failure during update",
          "description": "Should throw an error if the network request fails (e.g., network is down).",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and task object. Network is unavailable or request times out.",
            "when": "api.updateTask(id, task) is called",
            "then": "Throws a network error"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "updateTask_invalid_task_payload",
          "name": "Update with invalid task payload",
          "description": "Should throw an error if the task payload is invalid (e.g., missing required fields, backend returns 400).",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and an invalid task object (e.g., missing 'title'). Backend responds with 400 Bad Request.",
            "when": "api.updateTask(id, invalidTask) is called",
            "then": "Throws an error indicating invalid input"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "updateTask_empty_task_object",
          "name": "Update with empty task object",
          "description": "Should throw an error if the task object is empty and backend rejects the request.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and an empty task object {}. Backend responds with 400 Bad Request.",
            "when": "api.updateTask(id, {}) is called",
            "then": "Throws an error indicating invalid input"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "updateTask_id_as_null",
          "name": "Update with null as task ID",
          "description": "Should throw an error if the task ID is null.",
          "type": "negative",
          "test_setup": {
            "given": "A null task ID and a valid task object.",
            "when": "api.updateTask(null, task) is called",
            "then": "Throws an error due to invalid ID"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "updateTask_id_as_empty_string",
          "name": "Update with empty string as task ID",
          "description": "Should throw an error if the task ID is an empty string.",
          "type": "negative",
          "test_setup": {
            "given": "An empty string as task ID and a valid task object.",
            "when": "api.updateTask('', task) is called",
            "then": "Throws an error due to invalid ID"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "updateTask_response_missing_task_data",
          "name": "Backend response missing updated task data",
          "description": "Should throw an error if the backend responds with 200 OK but does not include the updated task data.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and task object. Backend responds with 200 OK but response body is empty or missing task data.",
            "when": "api.updateTask(id, task) is called",
            "then": "Throws an error due to missing data in response"
          },
          "implementation_id": "api_updateTask"
        }
      ]
    },
    {
      "implementation_id": "database_update_task",
      "test_cases": [
        {
          "id": "update_existing_task_completed_true",
          "name": "Update existing task to completed",
          "description": "Updates an existing task's completed status to true and verifies the update is persisted.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file with a task having id=1 and completed=false.",
            "when": "update_task(1, {\"id\": 1, \"title\": \"Test Task\", \"completed\": true}) is called",
            "then": "The returned task has completed=true and tasks.json is updated accordingly."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_existing_task_completed_false",
          "name": "Update existing task to pending",
          "description": "Updates an existing task's completed status to false and verifies the update is persisted.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file with a task having id=2 and completed=true.",
            "when": "update_task(2, {\"id\": 2, \"title\": \"Another Task\", \"completed\": false}) is called",
            "then": "The returned task has completed=false and tasks.json is updated accordingly."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_nonexistent_task",
          "name": "Update non-existent task",
          "description": "Attempts to update a task that does not exist and expects None as the result.",
          "type": "negative",
          "test_setup": {
            "given": "A tasks.json file with tasks having ids 1 and 2.",
            "when": "update_task(999, {\"id\": 999, \"title\": \"Ghost Task\", \"completed\": true}) is called",
            "then": "The function returns None and tasks.json remains unchanged."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_task_missing_completed_field",
          "name": "Update task missing completed field",
          "description": "Attempts to update a task without providing the completed field in the update data.",
          "type": "negative",
          "test_setup": {
            "given": "A tasks.json file with a task having id=3.",
            "when": "update_task(3, {\"id\": 3, \"title\": \"No Completed Field\"}) is called",
            "then": "The function returns the updated task, but the completed field is missing or unchanged depending on implementation."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_task_empty_tasks_list",
          "name": "Update task with empty tasks list",
          "description": "Attempts to update a task when tasks.json is empty.",
          "type": "negative",
          "test_setup": {
            "given": "An empty tasks.json file.",
            "when": "update_task(1, {\"id\": 1, \"title\": \"Any Task\", \"completed\": true}) is called",
            "then": "The function returns None and tasks.json remains empty."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_task_invalid_task_id_type",
          "name": "Update task with invalid task_id type",
          "description": "Attempts to update a task using a non-integer task_id.",
          "type": "negative",
          "test_setup": {
            "given": "A tasks.json file with a task having id=1.",
            "when": "update_task(\"one\", {\"id\": 1, \"title\": \"Test\", \"completed\": true}) is called",
            "then": "The function returns None or raises a TypeError, and tasks.json remains unchanged."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_task_partial_update",
          "name": "Update task with partial fields",
          "description": "Updates only some fields of a task (e.g., title but not completed) and verifies the other fields remain unchanged.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file with a task having id=4, title='Old Title', completed=false.",
            "when": "update_task(4, {\"id\": 4, \"title\": \"New Title\"}) is called",
            "then": "The returned task has title='New Title', completed=false, and tasks.json is updated accordingly."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_task_duplicate_ids",
          "name": "Update task when duplicate ids exist",
          "description": "Attempts to update a task when multiple tasks have the same id.",
          "type": "negative",
          "test_setup": {
            "given": "A tasks.json file with two tasks having id=5.",
            "when": "update_task(5, {\"id\": 5, \"title\": \"Duplicate\", \"completed\": true}) is called",
            "then": "Only the first matching task is updated, or an error is raised depending on implementation."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_task_large_number_of_tasks",
          "name": "Update task in large tasks list",
          "description": "Updates a task in a large tasks.json file to test performance and correctness.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file with 10,000 tasks, including one with id=5000.",
            "when": "update_task(5000, {\"id\": 5000, \"title\": \"Bulk Update\", \"completed\": true}) is called",
            "then": "The returned task has completed=true and tasks.json is updated correctly."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_task_invalid_update_data",
          "name": "Update task with invalid update data",
          "description": "Attempts to update a task with invalid update data (e.g., None or empty dict).",
          "type": "negative",
          "test_setup": {
            "given": "A tasks.json file with a task having id=6.",
            "when": "update_task(6, None) or update_task(6, {}) is called",
            "then": "The function returns None or raises an error, and tasks.json remains unchanged."
          },
          "implementation_id": "database_update_task"
        }
      ]
    },
    {
      "implementation_id": "filteredTasks_logic",
      "test_cases": [
        {
          "id": "filter_all_tasks",
          "name": "Filter All Tasks",
          "description": "Should return all tasks when filterStatus is 'all'.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: true}, {id: 2, completed: false}], filterStatus = 'all'",
            "when": "filteredTasks is called",
            "then": "Returns both tasks"
          },
          "implementation_id": "filteredTasks_logic"
        },
        {
          "id": "filter_completed_tasks",
          "name": "Filter Completed Tasks",
          "description": "Should return only completed tasks when filterStatus is 'completed'.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: true}, {id: 2, completed: false}], filterStatus = 'completed'",
            "when": "filteredTasks is called",
            "then": "Returns only the task with completed: true"
          },
          "implementation_id": "filteredTasks_logic"
        },
        {
          "id": "filter_pending_tasks",
          "name": "Filter Pending Tasks",
          "description": "Should return only pending tasks when filterStatus is 'pending'.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: true}, {id: 2, completed: false}], filterStatus = 'pending'",
            "when": "filteredTasks is called",
            "then": "Returns only the task with completed: false"
          },
          "implementation_id": "filteredTasks_logic"
        },
        {
          "id": "filter_no_tasks",
          "name": "Filter with No Tasks",
          "description": "Should return an empty array when tasks is empty, regardless of filterStatus.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [], filterStatus = 'completed'",
            "when": "filteredTasks is called",
            "then": "Returns []"
          },
          "implementation_id": "filteredTasks_logic"
        },
        {
          "id": "filter_all_completed",
          "name": "Filter All Completed Tasks",
          "description": "Should return all tasks when all are completed and filterStatus is 'completed'.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: true}, {id: 2, completed: true}], filterStatus = 'completed'",
            "when": "filteredTasks is called",
            "then": "Returns all tasks"
          },
          "implementation_id": "filteredTasks_logic"
        },
        {
          "id": "filter_all_pending",
          "name": "Filter All Pending Tasks",
          "description": "Should return all tasks when all are pending and filterStatus is 'pending'.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: false}, {id: 2, completed: false}], filterStatus = 'pending'",
            "when": "filteredTasks is called",
            "then": "Returns all tasks"
          },
          "implementation_id": "filteredTasks_logic"
        },
        {
          "id": "filter_none_completed",
          "name": "Filter None Completed",
          "description": "Should return an empty array when no tasks are completed and filterStatus is 'completed'.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: false}, {id: 2, completed: false}], filterStatus = 'completed'",
            "when": "filteredTasks is called",
            "then": "Returns []"
          },
          "implementation_id": "filteredTasks_logic"
        },
        {
          "id": "filter_none_pending",
          "name": "Filter None Pending",
          "description": "Should return an empty array when no tasks are pending and filterStatus is 'pending'.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: true}, {id: 2, completed: true}], filterStatus = 'pending'",
            "when": "filteredTasks is called",
            "then": "Returns []"
          },
          "implementation_id": "filteredTasks_logic"
        },
        {
          "id": "filter_status_case_sensitivity",
          "name": "Filter Status Case Sensitivity",
          "description": "Should treat filterStatus as case-sensitive and return all tasks for unknown casing.",
          "type": "negative",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: true}], filterStatus = 'Completed'",
            "when": "filteredTasks is called",
            "then": "Returns all tasks (since 'Completed' is not matched and falls to else branch)"
          },
          "implementation_id": "filteredTasks_logic"
        },
        {
          "id": "filter_status_unknown_value",
          "name": "Filter Status Unknown Value",
          "description": "Should return all tasks if filterStatus is an unknown value.",
          "type": "negative",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: true}], filterStatus = 'archived'",
            "when": "filteredTasks is called",
            "then": "Returns all tasks"
          },
          "implementation_id": "filteredTasks_logic"
        },
        {
          "id": "filter_tasks_with_missing_completed_field",
          "name": "Filter Tasks with Missing Completed Field",
          "description": "Should handle tasks missing the 'completed' field gracefully.",
          "type": "negative",
          "test_setup": {
            "given": "tasks = [{id: 1}, {id: 2, completed: false}], filterStatus = 'completed'",
            "when": "filteredTasks is called",
            "then": "Returns only tasks where completed is true (none in this case, since missing is falsy)"
          },
          "implementation_id": "filteredTasks_logic"
        },
        {
          "id": "filter_tasks_with_non_boolean_completed",
          "name": "Filter Tasks with Non-Boolean Completed Field",
          "description": "Should handle tasks where 'completed' is not a boolean.",
          "type": "negative",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: 'yes'}, {id: 2, completed: 1}], filterStatus = 'completed'",
            "when": "filteredTasks is called",
            "then": "Returns tasks where completed is truthy"
          },
          "implementation_id": "filteredTasks_logic"
        },
        {
          "id": "filter_status_null",
          "name": "Filter Status Null",
          "description": "Should return all tasks if filterStatus is null.",
          "type": "negative",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: true}], filterStatus = null",
            "when": "filteredTasks is called",
            "then": "Returns all tasks"
          },
          "implementation_id": "filteredTasks_logic"
        },
        {
          "id": "filter_status_undefined",
          "name": "Filter Status Undefined",
          "description": "Should return all tasks if filterStatus is undefined.",
          "type": "negative",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: true}], filterStatus = undefined",
            "when": "filteredTasks is called",
            "then": "Returns all tasks"
          },
          "implementation_id": "filteredTasks_logic"
        }
      ]
    },
    {
      "implementation_id": "handleToggleComplete_function",
      "test_cases": [
        {
          "id": "toggle_complete_success_all_filter",
          "name": "Toggle task completion successfully with 'All' filter",
          "description": "Toggles a task's completed status when the filter is set to 'All'. Verifies backend update and that the task list reloads with the toggled status.",
          "type": "positive",
          "test_setup": {
            "given": "A task with completed=false exists. The filter is set to 'All'.",
            "when": "handleToggleComplete is called with the task.",
            "then": "The backend receives an update to set completed=true. Tasks are reloaded and the toggled task remains visible in the list."
          },
          "implementation_id": "handleToggleComplete_function"
        },
        {
          "id": "toggle_complete_success_completed_filter",
          "name": "Toggle task completion with 'Completed' filter",
          "description": "Toggles a task from completed to pending when the filter is set to 'Completed'. Verifies backend update and that the task is removed from the filtered list.",
          "type": "positive",
          "test_setup": {
            "given": "A task with completed=true exists. The filter is set to 'Completed'.",
            "when": "handleToggleComplete is called with the task.",
            "then": "The backend receives an update to set completed=false. Tasks are reloaded and the toggled task is no longer visible in the filtered list."
          },
          "implementation_id": "handleToggleComplete_function"
        },
        {
          "id": "toggle_complete_success_pending_filter",
          "name": "Toggle task completion with 'Pending' filter",
          "description": "Toggles a task from pending to completed when the filter is set to 'Pending'. Verifies backend update and that the task is removed from the filtered list.",
          "type": "positive",
          "test_setup": {
            "given": "A task with completed=false exists. The filter is set to 'Pending'.",
            "when": "handleToggleComplete is called with the task.",
            "then": "The backend receives an update to set completed=true. Tasks are reloaded and the toggled task is no longer visible in the filtered list."
          },
          "implementation_id": "handleToggleComplete_function"
        },
        {
          "id": "toggle_complete_backend_failure",
          "name": "Backend update fails when toggling completion",
          "description": "Simulates a backend failure when toggling a task's completed status. Verifies error handling and that the UI does not update the task list.",
          "type": "negative",
          "test_setup": {
            "given": "A task exists. The backend will return an error on update.",
            "when": "handleToggleComplete is called with the task.",
            "then": "An error is handled (e.g., error message shown). The task list is not reloaded or reverted to the previous state."
          },
          "implementation_id": "handleToggleComplete_function"
        },
        {
          "id": "toggle_complete_reload_failure",
          "name": "Backend fails to reload tasks after toggle",
          "description": "Simulates a backend failure when reloading tasks after toggling. Verifies error handling and that the UI does not update the filtered list.",
          "type": "negative",
          "test_setup": {
            "given": "A task exists. The backend update succeeds, but reloading tasks fails.",
            "when": "handleToggleComplete is called with the task.",
            "then": "An error is handled (e.g., error message shown). The filtered list is not updated."
          },
          "implementation_id": "handleToggleComplete_function"
        },
        {
          "id": "toggle_complete_nonexistent_task",
          "name": "Toggle completion for a non-existent task",
          "description": "Attempts to toggle a task that does not exist in the backend. Verifies error handling.",
          "type": "negative",
          "test_setup": {
            "given": "A task object is passed that does not exist in the backend.",
            "when": "handleToggleComplete is called with the task.",
            "then": "An error is handled (e.g., error message shown). The task list remains unchanged."
          },
          "implementation_id": "handleToggleComplete_function"
        },
        {
          "id": "toggle_complete_idempotent",
          "name": "Toggle completion twice returns to original state",
          "description": "Toggles a task's completed status twice in succession and verifies the task returns to its original state.",
          "type": "positive",
          "test_setup": {
            "given": "A task with completed=false exists.",
            "when": "handleToggleComplete is called twice with the same task.",
            "then": "The backend receives two updates. After both calls, the task's completed status is false and the filtered list matches the initial state."
          },
          "implementation_id": "handleToggleComplete_function"
        },
        {
          "id": "toggle_complete_edge_case_empty_list",
          "name": "Toggle completion when task list is empty",
          "description": "Attempts to toggle a task when the task list is empty. Verifies proper handling.",
          "type": "negative",
          "test_setup": {
            "given": "The task list is empty.",
            "when": "handleToggleComplete is called with any task.",
            "then": "An error is handled or no action is taken. The task list remains empty."
          },
          "implementation_id": "handleToggleComplete_function"
        },
        {
          "id": "toggle_complete_edge_case_already_in_desired_state",
          "name": "Toggle completion for a task already in desired state",
          "description": "Attempts to toggle a task that is already in the desired completed state (e.g., toggling completed=true to completed=true). Verifies idempotency.",
          "type": "negative",
          "test_setup": {
            "given": "A task with completed=true exists. The backend update is a no-op.",
            "when": "handleToggleComplete is called with the task.",
            "then": "No changes occur in the backend or UI. The filtered list remains unchanged."
          },
          "implementation_id": "handleToggleComplete_function"
        },
        {
          "id": "toggle_complete_filter_switch_after_toggle",
          "name": "Switch filter after toggling completion",
          "description": "Toggles a task's completed status and then switches the filter. Verifies that the filtered list updates correctly.",
          "type": "positive",
          "test_setup": {
            "given": "A task with completed=false exists. The filter is set to 'Pending'.",
            "when": "handleToggleComplete is called with the task, then the filter is switched to 'Completed'.",
            "then": "The toggled task appears in the filtered list for 'Completed'."
          },
          "implementation_id": "handleToggleComplete_function"
        }
      ]
    },
    {
      "implementation_id": "api_getTasks_function",
      "test_cases": [
        {
          "id": "getTasks_success_returns_task_list",
          "name": "Successful fetch returns list of tasks",
          "description": "Verifies that api.getTasks returns the parsed list of tasks when the backend responds with HTTP 200 and valid JSON.",
          "type": "positive",
          "test_setup": {
            "given": "Backend /tasks endpoint is available and returns HTTP 200 with a valid JSON array of tasks.",
            "when": "api.getTasks is called",
            "then": "The function returns the parsed list of tasks as an array."
          },
          "implementation_id": "api_getTasks_function"
        },
        {
          "id": "getTasks_success_empty_list",
          "name": "Successful fetch returns empty list",
          "description": "Checks that api.getTasks returns an empty array when the backend responds with HTTP 200 and an empty list.",
          "type": "positive",
          "test_setup": {
            "given": "Backend /tasks endpoint returns HTTP 200 with an empty JSON array.",
            "when": "api.getTasks is called",
            "then": "The function returns an empty array."
          },
          "implementation_id": "api_getTasks_function"
        },
        {
          "id": "getTasks_backend_error_throws",
          "name": "Backend error response throws error",
          "description": "Ensures that api.getTasks throws an error when the backend responds with a non-200 status code (e.g., 500 Internal Server Error).",
          "type": "negative",
          "test_setup": {
            "given": "Backend /tasks endpoint returns HTTP 500.",
            "when": "api.getTasks is called",
            "then": "The function throws an error indicating the request failed."
          },
          "implementation_id": "api_getTasks_function"
        },
        {
          "id": "getTasks_network_failure_throws",
          "name": "Network failure throws error",
          "description": "Ensures that api.getTasks throws an error when the network request fails (e.g., network is offline or server is unreachable).",
          "type": "negative",
          "test_setup": {
            "given": "Network is offline or the backend server is unreachable.",
            "when": "api.getTasks is called",
            "then": "The function throws a network error."
          },
          "implementation_id": "api_getTasks_function"
        },
        {
          "id": "getTasks_invalid_json_throws",
          "name": "Invalid JSON response throws error",
          "description": "Checks that api.getTasks throws an error if the backend responds with HTTP 200 but the response body is not valid JSON.",
          "type": "negative",
          "test_setup": {
            "given": "Backend /tasks endpoint returns HTTP 200 with an invalid JSON body.",
            "when": "api.getTasks is called",
            "then": "The function throws a JSON parsing error."
          },
          "implementation_id": "api_getTasks_function"
        },
        {
          "id": "getTasks_unauthorized_throws",
          "name": "Unauthorized response throws error",
          "description": "Ensures that api.getTasks throws an error when the backend responds with HTTP 401 Unauthorized.",
          "type": "negative",
          "test_setup": {
            "given": "Backend /tasks endpoint returns HTTP 401 Unauthorized.",
            "when": "api.getTasks is called",
            "then": "The function throws an error indicating unauthorized access."
          },
          "implementation_id": "api_getTasks_function"
        },
        {
          "id": "getTasks_large_task_list",
          "name": "Fetch large list of tasks",
          "description": "Verifies that api.getTasks can handle and return a large list of tasks without performance or memory issues.",
          "type": "positive",
          "test_setup": {
            "given": "Backend /tasks endpoint returns HTTP 200 with a large JSON array (e.g., 10,000 tasks).",
            "when": "api.getTasks is called",
            "then": "The function returns the full list of tasks correctly."
          },
          "implementation_id": "api_getTasks_function"
        },
        {
          "id": "getTasks_malformed_task_object",
          "name": "Malformed task object in response",
          "description": "Checks how api.getTasks handles a response where one or more task objects are missing required fields.",
          "type": "negative",
          "test_setup": {
            "given": "Backend /tasks endpoint returns HTTP 200 with a JSON array containing malformed task objects (e.g., missing 'id' or 'title').",
            "when": "api.getTasks is called",
            "then": "The function throws an error or returns the malformed objects as-is, depending on implementation."
          },
          "implementation_id": "api_getTasks_function"
        },
        {
          "id": "getTasks_slow_response",
          "name": "Handles slow backend response",
          "description": "Verifies that api.getTasks can handle slow responses from the backend (e.g., delayed HTTP 200).",
          "type": "positive",
          "test_setup": {
            "given": "Backend /tasks endpoint responds with HTTP 200 after a significant delay (e.g., 10 seconds).",
            "when": "api.getTasks is called",
            "then": "The function eventually returns the parsed list of tasks, unless a timeout is implemented."
          },
          "implementation_id": "api_getTasks_function"
        },
        {
          "id": "getTasks_non_array_json",
          "name": "Non-array JSON response throws error",
          "description": "Ensures that api.getTasks throws an error if the backend returns HTTP 200 with a JSON object instead of an array.",
          "type": "negative",
          "test_setup": {
            "given": "Backend /tasks endpoint returns HTTP 200 with a JSON object (not an array).",
            "when": "api.getTasks is called",
            "then": "The function throws an error or returns the object, depending on implementation."
          },
          "implementation_id": "api_getTasks_function"
        }
      ]
    },
    {
      "implementation_id": "api_createTask_function",
      "test_cases": [
        {
          "id": "createTask_valid_task_success",
          "name": "Create task with valid data returns created task",
          "description": "Verifies that api.createTask returns the created task when provided with valid task data and the backend responds with a successful status.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task object with all required fields",
            "when": "api.createTask is called with this task",
            "then": "The function returns the created task as received from the backend"
          },
          "implementation_id": "api_createTask_function"
        },
        {
          "id": "createTask_minimal_task_success",
          "name": "Create task with minimal required fields",
          "description": "Checks that api.createTask works when only the minimal required fields are provided in the task object.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with only the minimal required fields",
            "when": "api.createTask is called",
            "then": "The function returns the created task as received from the backend"
          },
          "implementation_id": "api_createTask_function"
        },
        {
          "id": "createTask_extra_fields_ignored",
          "name": "Create task with extra fields",
          "description": "Ensures that extra fields in the task object are ignored by the backend and do not cause errors.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with valid fields plus additional, unexpected fields",
            "when": "api.createTask is called",
            "then": "The function returns the created task, and extra fields are ignored in the response"
          },
          "implementation_id": "api_createTask_function"
        },
        {
          "id": "createTask_empty_task_object",
          "name": "Create task with empty object fails",
          "description": "Checks that an error is thrown when an empty object is provided as the task.",
          "type": "negative",
          "test_setup": {
            "given": "An empty object {} as the task parameter",
            "when": "api.createTask is called",
            "then": "The function throws an error indicating invalid input or backend validation failure"
          },
          "implementation_id": "api_createTask_function"
        },
        {
          "id": "createTask_missing_required_field",
          "name": "Create task with missing required field fails",
          "description": "Ensures that missing required fields in the task object result in an error.",
          "type": "negative",
          "test_setup": {
            "given": "A task object missing one or more required fields",
            "when": "api.createTask is called",
            "then": "The function throws an error indicating which field is missing"
          },
          "implementation_id": "api_createTask_function"
        },
        {
          "id": "createTask_backend_returns_error",
          "name": "Backend returns error status",
          "description": "Verifies that api.createTask throws an error when the backend responds with an error status (e.g., 400, 500).",
          "type": "negative",
          "test_setup": {
            "given": "A valid task object and the backend is configured to return an error status",
            "when": "api.createTask is called",
            "then": "The function throws an error containing the backend's error message or status"
          },
          "implementation_id": "api_createTask_function"
        },
        {
          "id": "createTask_network_failure",
          "name": "Network failure during task creation",
          "description": "Checks that api.createTask throws an error if the network request fails (e.g., network is offline).",
          "type": "negative",
          "test_setup": {
            "given": "A valid task object and the network is unavailable",
            "when": "api.createTask is called",
            "then": "The function throws a network error"
          },
          "implementation_id": "api_createTask_function"
        },
        {
          "id": "createTask_large_payload",
          "name": "Create task with large payload",
          "description": "Tests the behavior when a task with very large field values is sent.",
          "type": "negative",
          "test_setup": {
            "given": "A task object with extremely large string fields (e.g., description > 10,000 chars)",
            "when": "api.createTask is called",
            "then": "The function throws an error if the backend rejects the payload, or returns the created task if accepted"
          },
          "implementation_id": "api_createTask_function"
        },
        {
          "id": "createTask_special_characters",
          "name": "Create task with special characters",
          "description": "Ensures that special characters in task fields are handled correctly and do not cause encoding issues.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with special characters (e.g., emoji, symbols) in text fields",
            "when": "api.createTask is called",
            "then": "The function returns the created task with special characters preserved"
          },
          "implementation_id": "api_createTask_function"
        },
        {
          "id": "createTask_duplicate_task",
          "name": "Create duplicate task",
          "description": "Checks the behavior when attempting to create a task that is a duplicate of an existing one.",
          "type": "negative",
          "test_setup": {
            "given": "A task object identical to an existing task in the database",
            "when": "api.createTask is called",
            "then": "The function throws an error if duplicates are not allowed, or returns the created task if duplicates are permitted"
          },
          "implementation_id": "api_createTask_function"
        }
      ]
    },
    {
      "implementation_id": "api_deleteTask_function",
      "test_cases": [
        {
          "id": "deleteTask_valid_id_success",
          "name": "Delete task with valid ID (success)",
          "description": "Should send a DELETE request to /tasks/{id} and succeed when the backend responds with 200 OK.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task ID exists in persistent storage and the backend is reachable.",
            "when": "deleteTask(valid_id) is called.",
            "then": "No value is returned and the task is removed from persistent storage."
          },
          "implementation_id": "api_deleteTask_function"
        },
        {
          "id": "deleteTask_nonexistent_id",
          "name": "Delete task with non-existent ID",
          "description": "Should throw an error when attempting to delete a task that does not exist.",
          "type": "negative",
          "test_setup": {
            "given": "A task ID that does not exist in persistent storage.",
            "when": "deleteTask(nonexistent_id) is called.",
            "then": "An error is thrown indicating the task was not found (e.g., 404 response)."
          },
          "implementation_id": "api_deleteTask_function"
        },
        {
          "id": "deleteTask_invalid_id_type",
          "name": "Delete task with invalid ID type",
          "description": "Should throw an error when the provided ID is not a valid type (e.g., null, undefined, or non-string/number).",
          "type": "negative",
          "test_setup": {
            "given": "An invalid ID value (null, undefined, object, array, etc.).",
            "when": "deleteTask(invalid_id) is called.",
            "then": "An error is thrown due to invalid input or failed request."
          },
          "implementation_id": "api_deleteTask_function"
        },
        {
          "id": "deleteTask_backend_error",
          "name": "Delete task when backend returns error",
          "description": "Should throw an error when the backend responds with a server error (e.g., 500 Internal Server Error).",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and the backend is configured to return a 500 error.",
            "when": "deleteTask(valid_id) is called.",
            "then": "An error is thrown indicating a server error."
          },
          "implementation_id": "api_deleteTask_function"
        },
        {
          "id": "deleteTask_network_failure",
          "name": "Delete task with network failure",
          "description": "Should throw an error when the network is unavailable or the request times out.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and the network is disconnected or the backend is unreachable.",
            "when": "deleteTask(valid_id) is called.",
            "then": "An error is thrown due to network failure."
          },
          "implementation_id": "api_deleteTask_function"
        },
        {
          "id": "deleteTask_id_with_special_characters",
          "name": "Delete task with ID containing special characters",
          "description": "Should handle IDs with special characters and either succeed or throw an error based on backend validation.",
          "type": "negative",
          "test_setup": {
            "given": "A task ID containing special characters (e.g., 'abc/123?').",
            "when": "deleteTask(special_char_id) is called.",
            "then": "An error is thrown if the backend rejects the ID, or the task is deleted if accepted."
          },
          "implementation_id": "api_deleteTask_function"
        },
        {
          "id": "deleteTask_id_as_zero",
          "name": "Delete task with ID as zero",
          "description": "Should handle the edge case where the task ID is zero.",
          "type": "positive",
          "test_setup": {
            "given": "A task with ID 0 exists in persistent storage.",
            "when": "deleteTask(0) is called.",
            "then": "No value is returned and the task is removed, or an error is thrown if ID 0 is invalid."
          },
          "implementation_id": "api_deleteTask_function"
        },
        {
          "id": "deleteTask_id_as_empty_string",
          "name": "Delete task with ID as empty string",
          "description": "Should throw an error when the task ID is an empty string.",
          "type": "negative",
          "test_setup": {
            "given": "An empty string as the task ID.",
            "when": "deleteTask('') is called.",
            "then": "An error is thrown due to invalid ID."
          },
          "implementation_id": "api_deleteTask_function"
        },
        {
          "id": "deleteTask_multiple_calls_same_id",
          "name": "Delete task multiple times with same ID",
          "description": "Should succeed on the first call and throw an error on subsequent calls for the same ID.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID exists in persistent storage.",
            "when": "deleteTask(valid_id) is called twice in succession.",
            "then": "First call succeeds, second call throws an error (e.g., 404 Not Found)."
          },
          "implementation_id": "api_deleteTask_function"
        },
        {
          "id": "deleteTask_backend_returns_non_json_error",
          "name": "Delete task when backend returns non-JSON error",
          "description": "Should throw an error when the backend returns a non-JSON error response (e.g., plain text or HTML).",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and the backend is configured to return a non-JSON error response.",
            "when": "deleteTask(valid_id) is called.",
            "then": "An error is thrown and the error message is handled gracefully."
          },
          "implementation_id": "api_deleteTask_function"
        }
      ]
    },
    {
      "implementation_id": "function_get_tasks",
      "test_cases": [
        {
          "id": "get_tasks_file_missing",
          "name": "test_file_missing_returns_empty_list",
          "description": "Should return an empty list if tasks.json does not exist.",
          "type": "positive",
          "test_setup": {
            "given": "tasks.json file does not exist in the expected location.",
            "when": "get_tasks() is called.",
            "then": "An empty list is returned."
          },
          "implementation_id": "function_get_tasks"
        },
        {
          "id": "get_tasks_empty_file",
          "name": "test_empty_file_returns_empty_list",
          "description": "Should return an empty list if tasks.json exists but is empty.",
          "type": "negative",
          "test_setup": {
            "given": "tasks.json exists but contains no data (empty file).",
            "when": "get_tasks() is called.",
            "then": "An empty list is returned."
          },
          "implementation_id": "function_get_tasks"
        },
        {
          "id": "get_tasks_invalid_json",
          "name": "test_invalid_json_returns_empty_list",
          "description": "Should return an empty list if tasks.json contains invalid JSON.",
          "type": "negative",
          "test_setup": {
            "given": "tasks.json exists but contains malformed JSON.",
            "when": "get_tasks() is called.",
            "then": "An empty list is returned."
          },
          "implementation_id": "function_get_tasks"
        },
        {
          "id": "get_tasks_valid_empty_array",
          "name": "test_valid_empty_array_returns_empty_list",
          "description": "Should return an empty list if tasks.json contains a valid empty array.",
          "type": "positive",
          "test_setup": {
            "given": "tasks.json contains '[]'.",
            "when": "get_tasks() is called.",
            "then": "An empty list is returned."
          },
          "implementation_id": "function_get_tasks"
        },
        {
          "id": "get_tasks_single_task",
          "name": "test_single_task_returns_task_object",
          "description": "Should return a list with one Task object if tasks.json contains one valid task.",
          "type": "positive",
          "test_setup": {
            "given": "tasks.json contains a JSON array with one valid task object.",
            "when": "get_tasks() is called.",
            "then": "A list with one Task object is returned, matching the data in the file."
          },
          "implementation_id": "function_get_tasks"
        },
        {
          "id": "get_tasks_multiple_tasks",
          "name": "test_multiple_tasks_returned_as_task_objects",
          "description": "Should return a list of Task objects if tasks.json contains multiple valid tasks.",
          "type": "positive",
          "test_setup": {
            "given": "tasks.json contains a JSON array with multiple valid task objects.",
            "when": "get_tasks() is called.",
            "then": "A list of Task objects is returned, each matching the data in the file."
          },
          "implementation_id": "function_get_tasks"
        },
        {
          "id": "get_tasks_partial_invalid_task",
          "name": "test_partial_invalid_task_skipped_or_error",
          "description": "Should handle a JSON array where one or more items are invalid (e.g., missing required fields).",
          "type": "negative",
          "test_setup": {
            "given": "tasks.json contains a JSON array with some valid and some invalid task objects.",
            "when": "get_tasks() is called.",
            "then": "Only valid Task objects are returned, or an empty list if all are invalid, depending on implementation."
          },
          "implementation_id": "function_get_tasks"
        },
        {
          "id": "get_tasks_non_array_json",
          "name": "test_non_array_json_returns_empty_list",
          "description": "Should return an empty list if tasks.json contains valid JSON that is not an array.",
          "type": "negative",
          "test_setup": {
            "given": "tasks.json contains a valid JSON object or value that is not a list.",
            "when": "get_tasks() is called.",
            "then": "An empty list is returned."
          },
          "implementation_id": "function_get_tasks"
        },
        {
          "id": "get_tasks_large_number_of_tasks",
          "name": "test_large_number_of_tasks",
          "description": "Should handle a large number of tasks efficiently and return all as Task objects.",
          "type": "positive",
          "test_setup": {
            "given": "tasks.json contains a JSON array with a large number of valid task objects (e.g., 10,000).",
            "when": "get_tasks() is called.",
            "then": "A list of Task objects is returned, matching the data in the file, with no performance issues."
          },
          "implementation_id": "function_get_tasks"
        },
        {
          "id": "get_tasks_unicode_and_special_characters",
          "name": "test_unicode_and_special_characters_in_tasks",
          "description": "Should correctly handle tasks with unicode and special characters in their fields.",
          "type": "positive",
          "test_setup": {
            "given": "tasks.json contains tasks with unicode and special characters in their fields.",
            "when": "get_tasks() is called.",
            "then": "A list of Task objects is returned with correct field values, including unicode and special characters."
          },
          "implementation_id": "function_get_tasks"
        }
      ]
    }
  ],
  "component": [
    {
      "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx",
      "test_cases": [
        {
          "id": "renders_all_fields",
          "name": "Render all form fields",
          "description": "Ensures the TaskForm renders all required input fields: title, description, priority dropdown, category dropdown, and due date picker.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered with default props",
            "when": "Component mounts",
            "then": "All form fields (title, description, priority, category, due date) are present in the DOM"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "submit_with_required_fields",
          "name": "Submit with only required fields",
          "description": "Tests submitting the form with only the required title field filled. Should call onSubmit with correct default values for optional fields.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered with a mock onSubmit handler",
            "when": "User enters a valid title and submits the form",
            "then": "onSubmit is called with { title, description: '', priority: default, category: '', due_date: '', completed: false }"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "submit_with_all_fields",
          "name": "Submit with all fields filled",
          "description": "Tests submitting the form with all fields filled. Should call onSubmit with all provided values.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered with a mock onSubmit handler",
            "when": "User fills title, description, selects priority and category, picks a due date, and submits",
            "then": "onSubmit is called with all provided values and completed: false"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "title_required_validation",
          "name": "Title field is required",
          "description": "Tests that submitting the form without a title shows a validation error and does not call onSubmit.",
          "type": "negative",
          "test_setup": {
            "given": "TaskForm is rendered with a mock onSubmit handler",
            "when": "User leaves the title field empty and submits the form",
            "then": "A validation error is displayed for the title field and onSubmit is not called"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "description_optional",
          "name": "Description field is optional",
          "description": "Tests that the description field can be left empty and the form still submits successfully.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered with a mock onSubmit handler",
            "when": "User fills only the title and submits the form",
            "then": "onSubmit is called with description as an empty string or undefined"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "priority_dropdown_options",
          "name": "Priority dropdown options",
          "description": "Ensures the priority dropdown contains all expected options (e.g., Low, Medium, High).",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered",
            "when": "User opens the priority dropdown",
            "then": "All expected priority options are visible"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "category_dropdown_optional",
          "name": "Category dropdown is optional",
          "description": "Tests that the category field can be left empty and the form still submits successfully.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered with a mock onSubmit handler",
            "when": "User fills only the title and submits the form",
            "then": "onSubmit is called with category as an empty string or undefined"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "due_date_picker_optional",
          "name": "Due date picker is optional",
          "description": "Tests that the due date field can be left empty and the form still submits successfully.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered with a mock onSubmit handler",
            "when": "User fills only the title and submits the form",
            "then": "onSubmit is called with due_date as an empty string or undefined"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "invalid_due_date_format",
          "name": "Invalid due date format",
          "description": "Tests that entering an invalid date format in the due date field prevents form submission and shows an error.",
          "type": "negative",
          "test_setup": {
            "given": "TaskForm is rendered with a mock onSubmit handler",
            "when": "User enters an invalid date in the due date field and submits",
            "then": "A validation error is displayed for due date and onSubmit is not called"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "on_submit_prevents_default",
          "name": "Form submit prevents default",
          "description": "Ensures that the form submission does not trigger a page reload (default form submission is prevented).",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered",
            "when": "User submits the form",
            "then": "The page does not reload and onSubmit is called"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "completed_field_default_false",
          "name": "Completed field defaults to false",
          "description": "Ensures that the completed field is always set to false when submitting a new task.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered with a mock onSubmit handler",
            "when": "User submits the form",
            "then": "onSubmit is called with completed: false"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "reset_form_after_submit",
          "name": "Form resets after successful submit",
          "description": "Tests that the form fields are cleared after a successful submission.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered with a mock onSubmit handler",
            "when": "User fills all fields and submits the form",
            "then": "All form fields are reset to their initial state"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "long_title_input",
          "name": "Long title input",
          "description": "Tests that the form handles very long titles gracefully without crashing or UI issues.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered",
            "when": "User enters a very long string in the title field and submits",
            "then": "onSubmit is called with the long title and the UI remains stable"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "special_characters_in_fields",
          "name": "Special characters in input fields",
          "description": "Tests that the form accepts special characters in title, description, and category fields.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered",
            "when": "User enters special characters in the fields and submits",
            "then": "onSubmit is called with the special character values"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        },
        {
          "id": "rapid_submit_clicks",
          "name": "Rapid submit button clicks",
          "description": "Tests that rapidly clicking the submit button does not cause multiple submissions or errors.",
          "type": "negative",
          "test_setup": {
            "given": "TaskForm is rendered with a mock onSubmit handler",
            "when": "User clicks the submit button multiple times quickly",
            "then": "onSubmit is called only once and no errors occur"
          },
          "implementation_id": "TaskForm_component_frontend_src_components_TaskForm_tsx"
        }
      ]
    },
    {
      "implementation_id": "TaskItem_onEdit_button",
      "test_cases": [
        {
          "id": "edit_button_triggers_onEdit_with_task",
          "name": "Edit button triggers onEdit with current task",
          "description": "Ensures that clicking the Edit button calls the onEdit callback with the current task object.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem is rendered with a valid task and a jest.fn() for onEdit",
            "when": "User clicks the Edit button",
            "then": "onEdit is called once with the task prop as argument"
          },
          "implementation_id": "TaskItem_onEdit_button"
        },
        {
          "id": "edit_button_not_rendered_without_onEdit",
          "name": "Edit button is not rendered if onEdit is undefined",
          "description": "Ensures that the Edit button is not rendered if the onEdit prop is not provided.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem is rendered with onEdit set to undefined",
            "when": "Component is rendered",
            "then": "Edit button is not present in the DOM"
          },
          "implementation_id": "TaskItem_onEdit_button"
        },
        {
          "id": "edit_button_disabled_when_task_is_null",
          "name": "Edit button does not trigger onEdit if task is null",
          "description": "Ensures that clicking Edit does not call onEdit if the task prop is null.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem is rendered with task set to null and a jest.fn() for onEdit",
            "when": "User clicks the Edit button",
            "then": "onEdit is not called"
          },
          "implementation_id": "TaskItem_onEdit_button"
        },
        {
          "id": "edit_button_with_completed_task",
          "name": "Edit button triggers onEdit for completed task",
          "description": "Ensures that the Edit button works for tasks marked as completed.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem is rendered with a completed task and a jest.fn() for onEdit",
            "when": "User clicks the Edit button",
            "then": "onEdit is called with the completed task"
          },
          "implementation_id": "TaskItem_onEdit_button"
        },
        {
          "id": "edit_button_with_minimal_task",
          "name": "Edit button triggers onEdit for minimal task object",
          "description": "Ensures that the Edit button works for a task with only required fields (e.g., no description, category, or due_date).",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem is rendered with a minimal task object and a jest.fn() for onEdit",
            "when": "User clicks the Edit button",
            "then": "onEdit is called with the minimal task"
          },
          "implementation_id": "TaskItem_onEdit_button"
        },
        {
          "id": "edit_button_multiple_clicks",
          "name": "Edit button can be clicked multiple times",
          "description": "Ensures that clicking the Edit button multiple times calls onEdit each time.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem is rendered with a valid task and a jest.fn() for onEdit",
            "when": "User clicks the Edit button three times",
            "then": "onEdit is called three times with the task prop"
          },
          "implementation_id": "TaskItem_onEdit_button"
        },
        {
          "id": "edit_button_does_not_affect_other_buttons",
          "name": "Edit button does not trigger other callbacks",
          "description": "Ensures that clicking the Edit button does not trigger onDelete or onToggleComplete.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem is rendered with jest.fn() for onEdit, onDelete, and onToggleComplete",
            "when": "User clicks the Edit button",
            "then": "Only onEdit is called; onDelete and onToggleComplete are not called"
          },
          "implementation_id": "TaskItem_onEdit_button"
        },
        {
          "id": "edit_button_accessibility",
          "name": "Edit button is accessible by role and label",
          "description": "Ensures that the Edit button is accessible via role and label for screen readers.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem is rendered with a valid task",
            "when": "Component is rendered",
            "then": "Edit button is present with role='button' and label 'Edit'"
          },
          "implementation_id": "TaskItem_onEdit_button"
        }
      ]
    },
    {
      "implementation_id": "App_TaskForm_component_usage",
      "test_cases": [
        {
          "id": "edit_form_renders_with_initial_task",
          "name": "renders_form_with_initial_task_data",
          "description": "The TaskForm should render with fields pre-filled with the editingTask's details when isFormOpen is true.",
          "type": "positive",
          "test_setup": {
            "given": "isFormOpen=true, editingTask set to a valid task object, TaskForm rendered with initialTask=editingTask",
            "when": "Component renders",
            "then": "All form fields are pre-filled with the values from editingTask"
          },
          "implementation_id": "App_TaskForm_component_usage"
        },
        {
          "id": "edit_form_submit_valid_data",
          "name": "submits_updated_task_on_valid_input",
          "description": "Submitting the form with valid changes should call onSubmit with the updated task data.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm rendered with initialTask, onSubmit mocked",
            "when": "User edits fields and submits the form",
            "then": "onSubmit is called with the updated task object"
          },
          "implementation_id": "App_TaskForm_component_usage"
        },
        {
          "id": "edit_form_cancel",
          "name": "cancels_editing_and_closes_form",
          "description": "Clicking the cancel button should close the form and clear editingTask.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm rendered with onCancel handler",
            "when": "User clicks the cancel button",
            "then": "onCancel is called, form is closed, and editingTask is cleared"
          },
          "implementation_id": "App_TaskForm_component_usage"
        },
        {
          "id": "edit_form_validation_required_fields",
          "name": "shows_error_on_missing_required_fields",
          "description": "Submitting the form with missing required fields should display validation errors and not call onSubmit.",
          "type": "negative",
          "test_setup": {
            "given": "TaskForm rendered with initialTask, onSubmit mocked",
            "when": "User clears a required field and submits the form",
            "then": "Validation error is shown and onSubmit is not called"
          },
          "implementation_id": "App_TaskForm_component_usage"
        },
        {
          "id": "edit_form_invalid_input",
          "name": "shows_error_on_invalid_input",
          "description": "Submitting the form with invalid input (e.g., too long, invalid format) should display validation errors.",
          "type": "negative",
          "test_setup": {
            "given": "TaskForm rendered with initialTask, onSubmit mocked",
            "when": "User enters invalid data and submits the form",
            "then": "Validation error is shown and onSubmit is not called"
          },
          "implementation_id": "App_TaskForm_component_usage"
        },
        {
          "id": "edit_form_no_changes_submit",
          "name": "submits_form_without_changes",
          "description": "Submitting the form without making any changes should still call onSubmit with the original task data.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm rendered with initialTask, onSubmit mocked",
            "when": "User submits the form without editing any fields",
            "then": "onSubmit is called with the original task object"
          },
          "implementation_id": "App_TaskForm_component_usage"
        },
        {
          "id": "edit_form_partial_update",
          "name": "submits_form_with_partial_changes",
          "description": "Submitting the form after changing only some fields should call onSubmit with the updated fields and unchanged others.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm rendered with initialTask, onSubmit mocked",
            "when": "User edits one field and submits the form",
            "then": "onSubmit is called with the task object reflecting only the changed field(s)"
          },
          "implementation_id": "App_TaskForm_component_usage"
        },
        {
          "id": "edit_form_keyboard_submit",
          "name": "submits_form_on_enter_key",
          "description": "Pressing Enter in a form field should submit the form if validation passes.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm rendered with initialTask, onSubmit mocked",
            "when": "User presses Enter in a form field",
            "then": "onSubmit is called if all validations pass"
          },
          "implementation_id": "App_TaskForm_component_usage"
        },
        {
          "id": "edit_form_escape_key_cancel",
          "name": "cancels_form_on_escape_key",
          "description": "Pressing Escape should trigger onCancel, closing the form and clearing editingTask.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm rendered with onCancel handler",
            "when": "User presses Escape key",
            "then": "onCancel is called, form is closed, and editingTask is cleared"
          },
          "implementation_id": "App_TaskForm_component_usage"
        },
        {
          "id": "edit_form_multiple_submits",
          "name": "prevents_multiple_submissions",
          "description": "Submitting the form multiple times rapidly should only call onSubmit once and prevent duplicate submissions.",
          "type": "negative",
          "test_setup": {
            "given": "TaskForm rendered with initialTask, onSubmit mocked",
            "when": "User clicks submit multiple times quickly",
            "then": "onSubmit is called only once"
          },
          "implementation_id": "App_TaskForm_component_usage"
        },
        {
          "id": "edit_form_preserves_state_on_reopen",
          "name": "preserves_form_state_on_reopen",
          "description": "If the form is closed and reopened with the same editingTask, the fields should be reset to the initialTask values.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm rendered with initialTask, user edits fields, then cancels and reopens form with same editingTask",
            "when": "Component re-renders",
            "then": "Form fields are reset to the original editingTask values"
          },
          "implementation_id": "App_TaskForm_component_usage"
        }
      ]
    },
    {
      "implementation_id": "TaskItem_onToggleComplete",
      "test_cases": [
        {
          "id": "toggle_complete_positive_done",
          "name": "Mark incomplete task as completed",
          "description": "When the user clicks the 'Done' button for an incomplete task, onToggleComplete is called with the correct task object.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: false and a mock onToggleComplete function.",
            "when": "User clicks the 'Done' button.",
            "then": "onToggleComplete is called once with the task object."
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "toggle_complete_positive_undo",
          "name": "Mark completed task as pending",
          "description": "When the user clicks the 'Undo' button for a completed task, onToggleComplete is called with the correct task object.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: true and a mock onToggleComplete function.",
            "when": "User clicks the 'Undo' button.",
            "then": "onToggleComplete is called once with the task object."
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "toggle_complete_button_label_done",
          "name": "Button label is 'Done' for incomplete task",
          "description": "The button label should be 'Done' when the task is not completed.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: false.",
            "when": "Component is rendered.",
            "then": "The button displays the label 'Done'."
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "toggle_complete_button_label_undo",
          "name": "Button label is 'Undo' for completed task",
          "description": "The button label should be 'Undo' when the task is completed.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: true.",
            "when": "Component is rendered.",
            "then": "The button displays the label 'Undo'."
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "toggle_complete_button_tooltip_done",
          "name": "Button tooltip is 'Mark as completed' for incomplete task",
          "description": "The button tooltip should be 'Mark as completed' when the task is not completed.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: false.",
            "when": "Component is rendered.",
            "then": "The button has the title 'Mark as completed'."
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "toggle_complete_button_tooltip_undo",
          "name": "Button tooltip is 'Mark as pending' for completed task",
          "description": "The button tooltip should be 'Mark as pending' when the task is completed.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: true.",
            "when": "Component is rendered.",
            "then": "The button has the title 'Mark as pending'."
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "toggle_complete_no_callback",
          "name": "No error if onToggleComplete is not provided",
          "description": "If onToggleComplete is undefined, clicking the button should not throw an error.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem receives a task prop and onToggleComplete is undefined.",
            "when": "User clicks the 'Done' or 'Undo' button.",
            "then": "No error is thrown and the component does not crash."
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "toggle_complete_multiple_clicks",
          "name": "Multiple rapid clicks on toggle button",
          "description": "Rapidly clicking the toggle button multiple times should call onToggleComplete the same number of times.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop and a mock onToggleComplete function.",
            "when": "User clicks the 'Done' or 'Undo' button three times quickly.",
            "then": "onToggleComplete is called three times with the task object."
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "toggle_complete_disabled_state",
          "name": "Button is enabled for all task states",
          "description": "The toggle button should always be enabled, regardless of the task's completed state.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: true or false.",
            "when": "Component is rendered.",
            "then": "The toggle button is not disabled."
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "toggle_complete_edge_case_null_task",
          "name": "Handle null task prop gracefully",
          "description": "If the task prop is null, the component should not throw and should not render the toggle button.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem receives a null task prop.",
            "when": "Component is rendered.",
            "then": "No error is thrown and the toggle button is not rendered."
          },
          "implementation_id": "TaskItem_onToggleComplete"
        }
      ]
    },
    {
      "implementation_id": "App_component",
      "test_cases": [
        {
          "id": "load_tasks_on_mount_success",
          "name": "Load tasks on mount (success)",
          "description": "Ensures tasks are fetched from the backend and rendered when the component mounts.",
          "type": "positive",
          "test_setup": {
            "given": "No tasks in state, backend returns a list of tasks",
            "when": "Component mounts",
            "then": "api.getTasks is called, tasks state is set, and tasks are rendered"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "load_tasks_on_mount_failure",
          "name": "Load tasks on mount (failure)",
          "description": "Handles backend failure when loading tasks on mount.",
          "type": "negative",
          "test_setup": {
            "given": "No tasks in state, backend returns error on getTasks",
            "when": "Component mounts",
            "then": "Error is handled gracefully, tasks state remains empty, and error message is displayed"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "create_task_success",
          "name": "Create task (success)",
          "description": "Creates a new task and reloads the task list.",
          "type": "positive",
          "test_setup": {
            "given": "Valid task data entered in form",
            "when": "User submits the create task form",
            "then": "api.createTask is called, loadTasks is triggered, and new task appears in the list"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "create_task_validation_failure",
          "name": "Create task (validation failure)",
          "description": "Prevents creation of a task with invalid or empty data.",
          "type": "negative",
          "test_setup": {
            "given": "Invalid or empty task data entered in form",
            "when": "User submits the create task form",
            "then": "api.createTask is not called, and validation error is shown"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "create_task_backend_failure",
          "name": "Create task (backend failure)",
          "description": "Handles backend error when creating a task.",
          "type": "negative",
          "test_setup": {
            "given": "Valid task data entered in form, backend returns error on createTask",
            "when": "User submits the create task form",
            "then": "Error is handled gracefully, task is not added, and error message is displayed"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "update_task_success",
          "name": "Update task (success)",
          "description": "Updates an existing task and reloads the task list.",
          "type": "positive",
          "test_setup": {
            "given": "Task exists, valid updated data provided",
            "when": "User submits the update task form",
            "then": "api.updateTask is called with correct id and data, loadTasks is triggered, and updated task is rendered"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "update_task_backend_failure",
          "name": "Update task (backend failure)",
          "description": "Handles backend error when updating a task.",
          "type": "negative",
          "test_setup": {
            "given": "Task exists, valid updated data provided, backend returns error on updateTask",
            "when": "User submits the update task form",
            "then": "Error is handled gracefully, task is not updated, and error message is displayed"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "delete_task_success",
          "name": "Delete task (success)",
          "description": "Deletes a task and removes it from the state.",
          "type": "positive",
          "test_setup": {
            "given": "Task exists in state",
            "when": "User clicks delete on a task",
            "then": "api.deleteTask is called with correct id, task is removed from state, and UI updates"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "delete_task_backend_failure",
          "name": "Delete task (backend failure)",
          "description": "Handles backend error when deleting a task.",
          "type": "negative",
          "test_setup": {
            "given": "Task exists in state, backend returns error on deleteTask",
            "when": "User clicks delete on a task",
            "then": "Error is handled gracefully, task remains in state, and error message is displayed"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "toggle_complete_success",
          "name": "Toggle task completion (success)",
          "description": "Toggles the completed status of a task and reloads the task list.",
          "type": "positive",
          "test_setup": {
            "given": "Task exists with completed=false",
            "when": "User toggles completion checkbox",
            "then": "api.updateTask is called with completed=true, loadTasks is triggered, and task is rendered as completed"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "toggle_complete_backend_failure",
          "name": "Toggle task completion (backend failure)",
          "description": "Handles backend error when toggling task completion.",
          "type": "negative",
          "test_setup": {
            "given": "Task exists, backend returns error on updateTask",
            "when": "User toggles completion checkbox",
            "then": "Error is handled gracefully, completed status does not change, and error message is displayed"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "persist_tasks_after_refresh",
          "name": "Persist tasks after page refresh",
          "description": "Ensures tasks are fetched from backend and rendered after a page refresh.",
          "type": "positive",
          "test_setup": {
            "given": "Tasks exist in backend, component state is empty after refresh",
            "when": "User refreshes the page",
            "then": "api.getTasks is called, tasks state is set, and tasks are rendered"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "empty_task_list",
          "name": "Render empty state when no tasks",
          "description": "Displays appropriate UI when there are no tasks to show.",
          "type": "positive",
          "test_setup": {
            "given": "Backend returns empty task list",
            "when": "Component mounts",
            "then": "No tasks are rendered, and empty state message is displayed"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "rapid_create_delete",
          "name": "Rapid create and delete operations",
          "description": "Handles rapid creation and deletion of tasks without inconsistent state.",
          "type": "positive",
          "test_setup": {
            "given": "User rapidly creates and deletes tasks",
            "when": "Multiple create and delete actions are performed in quick succession",
            "then": "State remains consistent, and UI accurately reflects the backend"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "update_nonexistent_task",
          "name": "Update non-existent task",
          "description": "Handles attempt to update a task that no longer exists in the backend.",
          "type": "negative",
          "test_setup": {
            "given": "Task is deleted from backend but present in UI",
            "when": "User tries to update the task",
            "then": "api.updateTask returns error, error is handled, and user is notified"
          },
          "implementation_id": "App_component"
        },
        {
          "id": "delete_nonexistent_task",
          "name": "Delete non-existent task",
          "description": "Handles attempt to delete a task that no longer exists in the backend.",
          "type": "negative",
          "test_setup": {
            "given": "Task is deleted from backend but present in UI",
            "when": "User tries to delete the task",
            "then": "api.deleteTask returns error, error is handled, and user is notified"
          },
          "implementation_id": "App_component"
        }
      ]
    },
    {
      "implementation_id": "filter_dropdown",
      "test_cases": [
        {
          "id": "status_dropdown_render_all_options",
          "name": "Render all status options",
          "description": "Verifies that the <select> dropdown renders with all three options: All Status, Pending, and Completed.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered with default state",
            "when": "No user interaction",
            "then": "Dropdown contains options with values 'all', 'pending', and 'completed'"
          },
          "implementation_id": "filter_dropdown"
        },
        {
          "id": "status_dropdown_default_value_all",
          "name": "Default value is All Status",
          "description": "Checks that the dropdown defaults to 'All Status' (value='all') when the component mounts.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered with default state",
            "when": "No user interaction",
            "then": "Dropdown value is 'all'"
          },
          "implementation_id": "filter_dropdown"
        },
        {
          "id": "status_dropdown_change_to_pending",
          "name": "Change filter to Pending",
          "description": "Ensures that selecting 'Pending' updates filterStatus to 'pending' and triggers filtering logic.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered with default state",
            "when": "User selects 'Pending' from dropdown",
            "then": "filterStatus is set to 'pending' and only pending tasks are shown"
          },
          "implementation_id": "filter_dropdown"
        },
        {
          "id": "status_dropdown_change_to_completed",
          "name": "Change filter to Completed",
          "description": "Ensures that selecting 'Completed' updates filterStatus to 'completed' and triggers filtering logic.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered with default state",
            "when": "User selects 'Completed' from dropdown",
            "then": "filterStatus is set to 'completed' and only completed tasks are shown"
          },
          "implementation_id": "filter_dropdown"
        },
        {
          "id": "status_dropdown_change_to_all",
          "name": "Change filter back to All",
          "description": "Ensures that selecting 'All Status' resets filterStatus to 'all' and all tasks are shown.",
          "type": "positive",
          "test_setup": {
            "given": "filterStatus is set to 'pending' or 'completed'",
            "when": "User selects 'All Status' from dropdown",
            "then": "filterStatus is set to 'all' and all tasks are shown"
          },
          "implementation_id": "filter_dropdown"
        },
        {
          "id": "status_dropdown_invalid_value",
          "name": "Handle invalid dropdown value",
          "description": "Tests the component's behavior if an invalid value is set programmatically.",
          "type": "negative",
          "test_setup": {
            "given": "Component is rendered",
            "when": "Dropdown value is set to an invalid value (e.g., 'archived')",
            "then": "filterStatus remains unchanged or resets to default; no crash occurs"
          },
          "implementation_id": "filter_dropdown"
        },
        {
          "id": "status_dropdown_keyboard_navigation",
          "name": "Keyboard navigation for dropdown",
          "description": "Verifies that the dropdown can be focused and changed using keyboard navigation.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered",
            "when": "User tabs to dropdown and uses arrow keys to change selection",
            "then": "filterStatus updates according to the selected option"
          },
          "implementation_id": "filter_dropdown"
        },
        {
          "id": "status_dropdown_no_options",
          "name": "Dropdown renders with no options",
          "description": "Tests the component's behavior if the options array is empty or undefined.",
          "type": "negative",
          "test_setup": {
            "given": "Component is rendered with no options provided",
            "when": "User opens dropdown",
            "then": "Dropdown is empty or shows a placeholder; no crash occurs"
          },
          "implementation_id": "filter_dropdown"
        },
        {
          "id": "status_dropdown_rapid_selection",
          "name": "Rapidly change dropdown selection",
          "description": "Ensures the component handles rapid changes in selection without errors or inconsistent state.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered",
            "when": "User quickly selects different options in succession",
            "then": "filterStatus always reflects the last selected value; UI remains consistent"
          },
          "implementation_id": "filter_dropdown"
        },
        {
          "id": "status_dropdown_disabled_state",
          "name": "Dropdown disabled state",
          "description": "Checks the behavior when the dropdown is disabled (if supported by the component).",
          "type": "negative",
          "test_setup": {
            "given": "Dropdown is rendered with disabled=true",
            "when": "User attempts to change selection",
            "then": "No change occurs; filterStatus remains unchanged"
          },
          "implementation_id": "filter_dropdown"
        }
      ]
    },
    {
      "implementation_id": "TaskItem_component",
      "test_cases": [
        {
          "id": "render_task_completed_status",
          "name": "Render Completed Task with Undo Button",
          "description": "Ensures that a completed task is rendered with the correct details and the button displays 'Undo'.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: true",
            "when": "Component is rendered",
            "then": "Task details are shown and the button label is 'Undo'"
          },
          "implementation_id": "TaskItem_component"
        },
        {
          "id": "render_task_pending_status",
          "name": "Render Pending Task with Done Button",
          "description": "Ensures that a pending task is rendered with the correct details and the button displays 'Done'.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: false",
            "when": "Component is rendered",
            "then": "Task details are shown and the button label is 'Done'"
          },
          "implementation_id": "TaskItem_component"
        },
        {
          "id": "toggle_complete_to_pending",
          "name": "Toggle Completed Task to Pending",
          "description": "Checks that clicking the 'Undo' button on a completed task calls onToggleComplete with the correct task.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a completed task and a mock onToggleComplete handler",
            "when": "User clicks the 'Undo' button",
            "then": "onToggleComplete is called with the task as argument"
          },
          "implementation_id": "TaskItem_component"
        },
        {
          "id": "toggle_pending_to_complete",
          "name": "Toggle Pending Task to Completed",
          "description": "Checks that clicking the 'Done' button on a pending task calls onToggleComplete with the correct task.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a pending task and a mock onToggleComplete handler",
            "when": "User clicks the 'Done' button",
            "then": "onToggleComplete is called with the task as argument"
          },
          "implementation_id": "TaskItem_component"
        },
        {
          "id": "filter_completed_tasks",
          "name": "Filter Shows Only Completed Tasks",
          "description": "Ensures that when the filter is set to 'Completed', only completed tasks are rendered.",
          "type": "positive",
          "test_setup": {
            "given": "filteredTasks contains only tasks with completed: true",
            "when": "Component is rendered",
            "then": "Only completed tasks are displayed"
          },
          "implementation_id": "TaskItem_component"
        },
        {
          "id": "filter_pending_tasks",
          "name": "Filter Shows Only Pending Tasks",
          "description": "Ensures that when the filter is set to 'Pending', only pending tasks are rendered.",
          "type": "positive",
          "test_setup": {
            "given": "filteredTasks contains only tasks with completed: false",
            "when": "Component is rendered",
            "then": "Only pending tasks are displayed"
          },
          "implementation_id": "TaskItem_component"
        },
        {
          "id": "filter_all_tasks",
          "name": "Filter Shows All Tasks",
          "description": "Ensures that when the filter is set to 'All', both completed and pending tasks are rendered.",
          "type": "positive",
          "test_setup": {
            "given": "filteredTasks contains both completed and pending tasks",
            "when": "Component is rendered",
            "then": "All tasks are displayed"
          },
          "implementation_id": "TaskItem_component"
        },
        {
          "id": "toggle_affects_filter",
          "name": "Toggling Task Status Affects Filtered List",
          "description": "Checks that toggling a task's status updates the filtered list according to the current filter.",
          "type": "positive",
          "test_setup": {
            "given": "filteredTasks contains a pending task, filter is set to 'Pending'",
            "when": "User clicks 'Done' to mark the task as completed",
            "then": "Task is removed from the list (no longer matches filter)"
          },
          "implementation_id": "TaskItem_component"
        },
        {
          "id": "no_tasks_rendered",
          "name": "No Tasks Rendered When List is Empty",
          "description": "Ensures that the component handles an empty filteredTasks array gracefully.",
          "type": "positive",
          "test_setup": {
            "given": "filteredTasks is an empty array",
            "when": "Component is rendered",
            "then": "No task items are displayed"
          },
          "implementation_id": "TaskItem_component"
        },
        {
          "id": "onToggleComplete_not_provided",
          "name": "Handle Missing onToggleComplete Prop",
          "description": "Checks that the component does not throw an error if onToggleComplete is not provided.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem is rendered without an onToggleComplete prop",
            "when": "User clicks the toggle button",
            "then": "No error is thrown and the component remains stable"
          },
          "implementation_id": "TaskItem_component"
        },
        {
          "id": "task_missing_completed_field",
          "name": "Handle Task Without Completed Field",
          "description": "Ensures the component handles a task object missing the 'completed' field without crashing.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem receives a task object without a 'completed' property",
            "when": "Component is rendered",
            "then": "Component does not crash and displays the task as pending by default"
          },
          "implementation_id": "TaskItem_component"
        },
        {
          "id": "button_disabled_during_toggle",
          "name": "Button Disabled During Toggle Operation",
          "description": "Checks that the toggle button is disabled while the toggle operation is in progress (if such state exists).",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem is in a loading/toggling state (e.g., isToggling: true)",
            "when": "Component is rendered",
            "then": "Toggle button is disabled"
          },
          "implementation_id": "TaskItem_component"
        },
        {
          "id": "rapid_toggle_clicks",
          "name": "Handle Rapid Toggle Clicks",
          "description": "Ensures that rapid consecutive clicks on the toggle button do not cause inconsistent state or multiple handler calls.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem receives a task and a mock onToggleComplete handler",
            "when": "User clicks the toggle button multiple times rapidly",
            "then": "onToggleComplete is called only once per toggle operation"
          },
          "implementation_id": "TaskItem_component"
        }
      ]
    },
    {
      "implementation_id": "App_filteredTasks_sort",
      "test_cases": [
        {
          "id": "sort_due_date_all_tasks",
          "name": "Sort tasks by due date (all tasks)",
          "description": "Ensures all tasks are sorted by ascending due date, with tasks missing due_date placed at the end.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id: 1, due_date: '2026-01-05'}, {id: 2, due_date: null}, {id: 3, due_date: '2026-01-01'}], filterStatus = 'all', sortOption = 'dueDate'",
            "when": "Component renders",
            "then": "Tasks are ordered: [id: 3, id: 1, id: 2]"
          },
          "implementation_id": "App_filteredTasks_sort"
        },
        {
          "id": "sort_priority_all_tasks",
          "name": "Sort tasks by priority (all tasks)",
          "description": "Ensures all tasks are sorted by priority: High, Medium, Low.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id: 1, priority: 'Low'}, {id: 2, priority: 'High'}, {id: 3, priority: 'Medium'}], filterStatus = 'all', sortOption = 'priority'",
            "when": "Component renders",
            "then": "Tasks are ordered: [id: 2, id: 3, id: 1]"
          },
          "implementation_id": "App_filteredTasks_sort"
        },
        {
          "id": "filter_completed_tasks",
          "name": "Filter completed tasks",
          "description": "Only completed tasks are shown when filterStatus is 'completed'.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: true}, {id: 2, completed: false}], filterStatus = 'completed', sortOption = 'dueDate'",
            "when": "Component renders",
            "then": "Only task with id: 1 is rendered"
          },
          "implementation_id": "App_filteredTasks_sort"
        },
        {
          "id": "filter_pending_tasks",
          "name": "Filter pending tasks",
          "description": "Only pending tasks are shown when filterStatus is 'pending'.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: true}, {id: 2, completed: false}], filterStatus = 'pending', sortOption = 'priority'",
            "when": "Component renders",
            "then": "Only task with id: 2 is rendered"
          },
          "implementation_id": "App_filteredTasks_sort"
        },
        {
          "id": "sort_due_date_with_nulls",
          "name": "Sort by due date with all null due dates",
          "description": "Tasks with all null due_date values remain in original order.",
          "type": "edge",
          "test_setup": {
            "given": "tasks = [{id: 1, due_date: null}, {id: 2, due_date: null}], filterStatus = 'all', sortOption = 'dueDate'",
            "when": "Component renders",
            "then": "Tasks are ordered: [id: 1, id: 2]"
          },
          "implementation_id": "App_filteredTasks_sort"
        },
        {
          "id": "sort_priority_with_invalid_value",
          "name": "Sort by priority with invalid priority value",
          "description": "Tasks with an invalid priority value are placed after valid priorities.",
          "type": "negative",
          "test_setup": {
            "given": "tasks = [{id: 1, priority: 'High'}, {id: 2, priority: 'Urgent'}], filterStatus = 'all', sortOption = 'priority'",
            "when": "Component renders",
            "then": "Task with id: 2 is placed after id: 1"
          },
          "implementation_id": "App_filteredTasks_sort"
        },
        {
          "id": "sort_priority_with_missing_priority",
          "name": "Sort by priority with missing priority field",
          "description": "Tasks missing the priority field are placed after those with valid priorities.",
          "type": "negative",
          "test_setup": {
            "given": "tasks = [{id: 1, priority: 'Medium'}, {id: 2}], filterStatus = 'all', sortOption = 'priority'",
            "when": "Component renders",
            "then": "Task with id: 2 is placed after id: 1"
          },
          "implementation_id": "App_filteredTasks_sort"
        },
        {
          "id": "sort_due_date_with_invalid_date",
          "name": "Sort by due date with invalid date format",
          "description": "Tasks with invalid due_date formats are treated as missing and placed at the end.",
          "type": "negative",
          "test_setup": {
            "given": "tasks = [{id: 1, due_date: 'invalid-date'}, {id: 2, due_date: '2026-01-01'}], filterStatus = 'all', sortOption = 'dueDate'",
            "when": "Component renders",
            "then": "Task with id: 2 is before id: 1"
          },
          "implementation_id": "App_filteredTasks_sort"
        },
        {
          "id": "empty_task_list",
          "name": "Render with empty task list",
          "description": "Component renders correctly when there are no tasks.",
          "type": "edge",
          "test_setup": {
            "given": "tasks = [], filterStatus = 'all', sortOption = 'dueDate'",
            "when": "Component renders",
            "then": "No tasks are rendered"
          },
          "implementation_id": "App_filteredTasks_sort"
        },
        {
          "id": "user_changes_sort_option",
          "name": "User changes sort option",
          "description": "Tasks are re-sorted when the user changes the sort option.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id: 1, due_date: '2026-01-05', priority: 'Low'}, {id: 2, due_date: '2026-01-01', priority: 'High'}], filterStatus = 'all', sortOption = 'dueDate'",
            "when": "User changes sortOption to 'priority'",
            "then": "Tasks are reordered: [id: 2, id: 1]"
          },
          "implementation_id": "App_filteredTasks_sort"
        },
        {
          "id": "user_changes_filter_status",
          "name": "User changes filter status",
          "description": "Tasks are re-filtered when the user changes the filter status.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: true}, {id: 2, completed: false}], filterStatus = 'all', sortOption = 'priority'",
            "when": "User changes filterStatus to 'completed'",
            "then": "Only task with id: 1 is rendered"
          },
          "implementation_id": "App_filteredTasks_sort"
        },
        {
          "id": "all_tasks_filtered_out",
          "name": "All tasks filtered out",
          "description": "No tasks are rendered if none match the filter criteria.",
          "type": "edge",
          "test_setup": {
            "given": "tasks = [{id: 1, completed: false}], filterStatus = 'completed', sortOption = 'dueDate'",
            "when": "Component renders",
            "then": "No tasks are rendered"
          },
          "implementation_id": "App_filteredTasks_sort"
        }
      ]
    },
    {
      "implementation_id": "App_sortOption_select",
      "test_cases": [
        {
          "id": "sort_dropdown_renders_options",
          "name": "renders_sort_options",
          "description": "Ensures the dropdown renders with both 'Sort by Due Date' and 'Sort by Priority' options.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered with default state.",
            "when": "No user interaction.",
            "then": "Dropdown contains options: 'Sort by Due Date' and 'Sort by Priority'."
          },
          "implementation_id": "App_sortOption_select"
        },
        {
          "id": "sort_dropdown_default_selection",
          "name": "default_option_selected",
          "description": "Checks that the default sort option is selected on initial render.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered with default state.",
            "when": "No user interaction.",
            "then": "The default option (e.g., 'Sort by Due Date') is selected."
          },
          "implementation_id": "App_sortOption_select"
        },
        {
          "id": "sort_dropdown_change_to_priority",
          "name": "change_sort_to_priority",
          "description": "Verifies that selecting 'Sort by Priority' updates the sortOption state and triggers sorting.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered with default state and a list of tasks.",
            "when": "User selects 'Sort by Priority' from the dropdown.",
            "then": "sortOption state updates to 'priority' and filteredTasks are sorted by priority."
          },
          "implementation_id": "App_sortOption_select"
        },
        {
          "id": "sort_dropdown_change_to_due_date",
          "name": "change_sort_to_due_date",
          "description": "Verifies that selecting 'Sort by Due Date' updates the sortOption state and triggers sorting.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered with sortOption set to 'priority' and a list of tasks.",
            "when": "User selects 'Sort by Due Date' from the dropdown.",
            "then": "sortOption state updates to 'dueDate' and filteredTasks are sorted by due date."
          },
          "implementation_id": "App_sortOption_select"
        },
        {
          "id": "sort_dropdown_state_persists_on_rerender",
          "name": "state_persists_on_rerender",
          "description": "Ensures the selected sort option persists after a re-render (e.g., parent state change).",
          "type": "positive",
          "test_setup": {
            "given": "User has selected 'Sort by Priority'.",
            "when": "Component is re-rendered due to unrelated parent state change.",
            "then": "'Sort by Priority' remains selected."
          },
          "implementation_id": "App_sortOption_select"
        },
        {
          "id": "sort_dropdown_invalid_option",
          "name": "handle_invalid_option",
          "description": "Tests component behavior when an invalid sort option is set in state.",
          "type": "negative",
          "test_setup": {
            "given": "sortOption state is set to an invalid value (e.g., 'unknown').",
            "when": "Component renders.",
            "then": "Dropdown displays no selection or falls back to default; no crash occurs."
          },
          "implementation_id": "App_sortOption_select"
        },
        {
          "id": "sort_dropdown_keyboard_navigation",
          "name": "keyboard_navigation",
          "description": "Ensures the dropdown is accessible via keyboard navigation.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered.",
            "when": "User navigates and selects an option using keyboard (Tab, Arrow keys, Enter).",
            "then": "sortOption state updates accordingly and filteredTasks are sorted."
          },
          "implementation_id": "App_sortOption_select"
        },
        {
          "id": "sort_dropdown_no_tasks",
          "name": "no_tasks_behavior",
          "description": "Checks dropdown behavior when there are no tasks to sort.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered with an empty tasks list.",
            "when": "User selects any sort option.",
            "then": "No errors occur; filteredTasks remains empty."
          },
          "implementation_id": "App_sortOption_select"
        },
        {
          "id": "sort_dropdown_rapid_selection",
          "name": "rapid_option_changes",
          "description": "Tests component stability when user rapidly changes sort options.",
          "type": "negative",
          "test_setup": {
            "given": "Component is rendered with a list of tasks.",
            "when": "User quickly toggles between sort options multiple times.",
            "then": "No errors or crashes; sortOption state and filteredTasks update correctly."
          },
          "implementation_id": "App_sortOption_select"
        },
        {
          "id": "sort_dropdown_missing_props",
          "name": "missing_props_handling",
          "description": "Tests component behavior if required props (e.g., tasks) are missing or undefined.",
          "type": "negative",
          "test_setup": {
            "given": "Component is rendered with missing or undefined tasks prop.",
            "when": "User interacts with the dropdown.",
            "then": "Component handles gracefully without crashing; may show empty list."
          },
          "implementation_id": "App_sortOption_select"
        }
      ]
    },
    {
      "implementation_id": "component_TaskItem",
      "test_cases": [
        {
          "id": "completed_task_card_opacity",
          "name": "Card opacity for completed task",
          "description": "Ensures that a completed task renders with faded opacity and the 'opacity-50' class.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: true",
            "when": "Component renders",
            "then": "The card element has style opacity 0.7 and includes the 'opacity-50' class"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "pending_task_card_opacity",
          "name": "Card opacity for pending task",
          "description": "Ensures that a pending (not completed) task renders with normal opacity and does not have the 'opacity-50' class.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: false",
            "when": "Component renders",
            "then": "The card element has style opacity 1 and does not include the 'opacity-50' class"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "completed_task_title_line_through",
          "name": "Line-through style for completed task title",
          "description": "Checks that the task title is rendered with a line-through text decoration when the task is completed.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: true",
            "when": "Component renders",
            "then": "The task title element has a line-through text decoration"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "pending_task_title_no_line_through",
          "name": "No line-through for pending task title",
          "description": "Checks that the task title is rendered with normal text when the task is not completed.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: false",
            "when": "Component renders",
            "then": "The task title element does not have a line-through text decoration"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "completed_task_button_undo",
          "name": "Undo button for completed task",
          "description": "Verifies that the button label is 'Undo', style is 'btn-ghost', and title is 'Mark as pending' for completed tasks.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: true",
            "when": "Component renders",
            "then": "The toggle button label is 'Undo', has class 'btn-ghost', and title 'Mark as pending'"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "pending_task_button_done",
          "name": "Done button for pending task",
          "description": "Verifies that the button label is 'Done', style is 'btn-primary', and title is 'Mark as completed' for pending tasks.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: false",
            "when": "Component renders",
            "then": "The toggle button label is 'Done', has class 'btn-primary', and title 'Mark as completed'"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "toggle_completion_from_pending",
          "name": "Toggle completion from pending to completed",
          "description": "Checks that clicking the 'Done' button triggers the completion toggle handler and updates the UI to completed state.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: false and a mock toggle handler",
            "when": "User clicks the 'Done' button",
            "then": "The toggle handler is called and the card updates to completed visual state"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "toggle_completion_from_completed",
          "name": "Toggle completion from completed to pending",
          "description": "Checks that clicking the 'Undo' button triggers the completion toggle handler and updates the UI to pending state.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: true and a mock toggle handler",
            "when": "User clicks the 'Undo' button",
            "then": "The toggle handler is called and the card updates to pending visual state"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "render_priority_and_category_badges",
          "name": "Render priority and category badges",
          "description": "Ensures that the priority and category badges are rendered with the correct values.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with priority and category fields",
            "when": "Component renders",
            "then": "Priority and category badges are displayed with correct text"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "render_description_and_due_date_present",
          "name": "Render description and due date if present",
          "description": "Checks that the description and due date are rendered when provided in the task prop.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with description and dueDate fields",
            "when": "Component renders",
            "then": "Description and due date are displayed"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "no_description_or_due_date",
          "name": "No description or due date",
          "description": "Ensures that the description and due date elements are not rendered if not present in the task prop.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem receives a task prop without description and dueDate fields",
            "when": "Component renders",
            "then": "No description or due date elements are present in the output"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "edit_button_presence",
          "name": "Edit button is rendered",
          "description": "Checks that the edit button is present and triggers the edit handler when clicked.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop and a mock edit handler",
            "when": "User clicks the edit button",
            "then": "The edit handler is called"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "delete_button_presence",
          "name": "Delete button is rendered",
          "description": "Checks that the delete button is present and triggers the delete handler when clicked.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop and a mock delete handler",
            "when": "User clicks the delete button",
            "then": "The delete handler is called"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "missing_task_prop",
          "name": "Component handles missing task prop",
          "description": "Ensures the component handles missing or undefined task prop gracefully without crashing.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem is rendered without a task prop or with task as undefined",
            "when": "Component renders",
            "then": "Component does not throw an error and displays fallback UI or nothing"
          },
          "implementation_id": "component_TaskItem"
        },
        {
          "id": "invalid_task_fields",
          "name": "Component handles invalid task fields",
          "description": "Ensures the component handles invalid or missing fields in the task prop gracefully.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem receives a task prop with missing or invalid fields (e.g., title is undefined)",
            "when": "Component renders",
            "then": "Component does not throw and displays fallback or empty values for missing fields"
          },
          "implementation_id": "component_TaskItem"
        }
      ]
    }
  ],
  "endpoint": [
    {
      "implementation_id": "backend_update_task_endpoint",
      "test_cases": [
        {
          "id": "update_task_success_completed",
          "name": "Update Task Status to Completed - Success",
          "description": "Successfully update an existing task's status to completed.",
          "type": "positive",
          "request_method": "PUT",
          "request_url": "/tasks/1",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"status\": \"completed\"}",
          "response_status_code": 200,
          "response_body_json": "{\"id\": 1, \"status\": \"completed\"}",
          "test_setup": {
            "given": "A task with id 1 exists and is currently pending.",
            "when": "A PUT request is sent to /tasks/1 with status set to completed.",
            "then": "The response status is 200 and the returned task has status completed."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_success_pending",
          "name": "Update Task Status to Pending - Success",
          "description": "Successfully update an existing task's status to pending.",
          "type": "positive",
          "request_method": "PUT",
          "request_url": "/tasks/2",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"status\": \"pending\"}",
          "response_status_code": 200,
          "response_body_json": "{\"id\": 2, \"status\": \"pending\"}",
          "test_setup": {
            "given": "A task with id 2 exists and is currently completed.",
            "when": "A PUT request is sent to /tasks/2 with status set to pending.",
            "then": "The response status is 200 and the returned task has status pending."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_not_found",
          "name": "Update Non-Existent Task",
          "description": "Attempt to update a task that does not exist, expecting a 404 error.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/9999",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"status\": \"completed\"}",
          "response_status_code": 404,
          "response_body_json": "{\"detail\": \"Task not found\"}",
          "test_setup": {
            "given": "No task with id 9999 exists.",
            "when": "A PUT request is sent to /tasks/9999.",
            "then": "The response status is 404 with an appropriate error message."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_invalid_status",
          "name": "Update Task with Invalid Status Value",
          "description": "Attempt to update a task with an invalid status value, expecting a 422 validation error.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/1",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"status\": \"in_progress\"}",
          "response_status_code": 422,
          "response_body_json": "{\"detail\": \"Invalid status value\"}",
          "test_setup": {
            "given": "A task with id 1 exists.",
            "when": "A PUT request is sent to /tasks/1 with status set to an invalid value.",
            "then": "The response status is 422 with a validation error message."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_missing_status",
          "name": "Update Task with Missing Status Field",
          "description": "Attempt to update a task without providing the status field, expecting a 422 validation error.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/1",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 422,
          "response_body_json": "{\"detail\": \"Missing status field\"}",
          "test_setup": {
            "given": "A task with id 1 exists.",
            "when": "A PUT request is sent to /tasks/1 with an empty body.",
            "then": "The response status is 422 with a validation error message."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_invalid_id_type",
          "name": "Update Task with Non-Integer ID",
          "description": "Attempt to update a task using a non-integer task_id, expecting a 422 validation error.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/abc",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"status\": \"completed\"}",
          "response_status_code": 422,
          "response_body_json": "{\"detail\": \"Invalid task_id type\"}",
          "test_setup": {
            "given": "The task_id in the URL is a non-integer string.",
            "when": "A PUT request is sent to /tasks/abc.",
            "then": "The response status is 422 with a validation error message."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_extra_fields",
          "name": "Update Task with Extra Fields",
          "description": "Update a task with additional, unexpected fields in the request body. The extra fields should be ignored.",
          "type": "positive",
          "request_method": "PUT",
          "request_url": "/tasks/1",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"status\": \"completed\", \"extra\": \"ignore_me\"}",
          "response_status_code": 200,
          "response_body_json": "{\"id\": 1, \"status\": \"completed\"}",
          "test_setup": {
            "given": "A task with id 1 exists.",
            "when": "A PUT request is sent to /tasks/1 with status and an extra field.",
            "then": "The response status is 200 and the extra field is ignored in the response."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_empty_body",
          "name": "Update Task with Empty Body",
          "description": "Attempt to update a task with an empty request body, expecting a 422 validation error.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/1",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "",
          "response_status_code": 422,
          "response_body_json": "{\"detail\": \"Request body is empty\"}",
          "test_setup": {
            "given": "A task with id 1 exists.",
            "when": "A PUT request is sent to /tasks/1 with an empty body.",
            "then": "The response status is 422 with a validation error message."
          },
          "implementation_id": "backend_update_task_endpoint"
        }
      ]
    },
    {
      "implementation_id": "endpoint_get_tasks",
      "test_cases": [
        {
          "id": "read_tasks_all_tasks_exist",
          "name": "get_all_tasks_success",
          "description": "Verify that the endpoint returns all tasks when tasks exist in the database.",
          "type": "positive",
          "request_method": "GET",
          "request_url": "/tasks",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 200,
          "response_body_json": "[{\"id\":1,\"title\":\"Task 1\",\"completed\":true},{\"id\":2,\"title\":\"Task 2\",\"completed\":false}]",
          "test_setup": {
            "given": "Database contains two tasks: one completed, one pending.",
            "when": "A GET request is sent to /tasks.",
            "then": "The response contains both tasks with correct completion status."
          },
          "implementation_id": "endpoint_get_tasks"
        },
        {
          "id": "read_tasks_no_tasks",
          "name": "get_no_tasks_returns_empty_list",
          "description": "Verify that the endpoint returns an empty list when there are no tasks in the database.",
          "type": "positive",
          "request_method": "GET",
          "request_url": "/tasks",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 200,
          "response_body_json": "[]",
          "test_setup": {
            "given": "Database contains no tasks.",
            "when": "A GET request is sent to /tasks.",
            "then": "The response is an empty list."
          },
          "implementation_id": "endpoint_get_tasks"
        },
        {
          "id": "read_tasks_all_completed",
          "name": "get_all_tasks_completed",
          "description": "Verify that the endpoint returns all tasks when all tasks are completed.",
          "type": "positive",
          "request_method": "GET",
          "request_url": "/tasks",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 200,
          "response_body_json": "[{\"id\":1,\"title\":\"Task 1\",\"completed\":true},{\"id\":2,\"title\":\"Task 2\",\"completed\":true}]",
          "test_setup": {
            "given": "Database contains two completed tasks.",
            "when": "A GET request is sent to /tasks.",
            "then": "The response contains both tasks with completed status true."
          },
          "implementation_id": "endpoint_get_tasks"
        },
        {
          "id": "read_tasks_all_pending",
          "name": "get_all_tasks_pending",
          "description": "Verify that the endpoint returns all tasks when all tasks are pending.",
          "type": "positive",
          "request_method": "GET",
          "request_url": "/tasks",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 200,
          "response_body_json": "[{\"id\":1,\"title\":\"Task 1\",\"completed\":false},{\"id\":2,\"title\":\"Task 2\",\"completed\":false}]",
          "test_setup": {
            "given": "Database contains two pending tasks.",
            "when": "A GET request is sent to /tasks.",
            "then": "The response contains both tasks with completed status false."
          },
          "implementation_id": "endpoint_get_tasks"
        },
        {
          "id": "read_tasks_large_number",
          "name": "get_large_number_of_tasks",
          "description": "Verify that the endpoint handles a large number of tasks efficiently.",
          "type": "positive",
          "request_method": "GET",
          "request_url": "/tasks",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 200,
          "response_body_json": "[{\"id\":1,\"title\":\"Task 1\",\"completed\":false},...,{\"id\":1000,\"title\":\"Task 1000\",\"completed\":true}]",
          "test_setup": {
            "given": "Database contains 1000 tasks with varying completion status.",
            "when": "A GET request is sent to /tasks.",
            "then": "The response contains all 1000 tasks."
          },
          "implementation_id": "endpoint_get_tasks"
        },
        {
          "id": "read_tasks_invalid_method_post",
          "name": "post_tasks_not_allowed",
          "description": "Verify that POST method is not allowed on the /tasks endpoint.",
          "type": "negative",
          "request_method": "POST",
          "request_url": "/tasks",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 405,
          "response_body_json": "{\"detail\":\"Method Not Allowed\"}",
          "test_setup": {
            "given": "API server is running.",
            "when": "A POST request is sent to /tasks.",
            "then": "The response status is 405 Method Not Allowed."
          },
          "implementation_id": "endpoint_get_tasks"
        },
        {
          "id": "read_tasks_invalid_method_put",
          "name": "put_tasks_not_allowed",
          "description": "Verify that PUT method is not allowed on the /tasks endpoint.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 405,
          "response_body_json": "{\"detail\":\"Method Not Allowed\"}",
          "test_setup": {
            "given": "API server is running.",
            "when": "A PUT request is sent to /tasks.",
            "then": "The response status is 405 Method Not Allowed."
          },
          "implementation_id": "endpoint_get_tasks"
        },
        {
          "id": "read_tasks_invalid_method_delete",
          "name": "delete_tasks_not_allowed",
          "description": "Verify that DELETE method is not allowed on the /tasks endpoint.",
          "type": "negative",
          "request_method": "DELETE",
          "request_url": "/tasks",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 405,
          "response_body_json": "{\"detail\":\"Method Not Allowed\"}",
          "test_setup": {
            "given": "API server is running.",
            "when": "A DELETE request is sent to /tasks.",
            "then": "The response status is 405 Method Not Allowed."
          },
          "implementation_id": "endpoint_get_tasks"
        },
        {
          "id": "read_tasks_malformed_accept_header",
          "name": "get_tasks_malformed_accept_header",
          "description": "Verify that the endpoint handles malformed Accept headers gracefully.",
          "type": "negative",
          "request_method": "GET",
          "request_url": "/tasks",
          "request_headers": {
            "Accept": "invalid/type"
          },
          "request_body_json": "{}",
          "response_status_code": 406,
          "response_body_json": "{\"detail\":\"Not Acceptable\"}",
          "test_setup": {
            "given": "API server is running.",
            "when": "A GET request with an invalid Accept header is sent to /tasks.",
            "then": "The response status is 406 Not Acceptable."
          },
          "implementation_id": "endpoint_get_tasks"
        },
        {
          "id": "read_tasks_unexpected_content_type",
          "name": "get_tasks_unexpected_content_type",
          "description": "Verify that the endpoint ignores unexpected Content-Type headers for GET requests.",
          "type": "positive",
          "request_method": "GET",
          "request_url": "/tasks",
          "request_headers": {
            "Content-Type": "application/xml"
          },
          "request_body_json": "{}",
          "response_status_code": 200,
          "response_body_json": "[{\"id\":1,\"title\":\"Task 1\",\"completed\":false}]",
          "test_setup": {
            "given": "Database contains one pending task.",
            "when": "A GET request with Content-Type: application/xml is sent to /tasks.",
            "then": "The response is 200 OK with the list of tasks in JSON."
          },
          "implementation_id": "endpoint_get_tasks"
        }
      ]
    }
  ]
}