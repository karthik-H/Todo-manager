{
  "function": [
    {
      "implementation_id": "App_handleDeleteTask",
      "test_cases": [
        {
          "id": "delete_existing_task_success",
          "name": "Delete an existing task successfully",
          "description": "Verifies that handleDeleteTask removes the task from state when api.deleteTask succeeds.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks state containing a task with id=1. api.deleteTask is mocked to resolve successfully.",
            "when": "handleDeleteTask(1) is called.",
            "then": "The task with id=1 is removed from the tasks state. No alert is shown."
          },
          "implementation_id": "App_handleDeleteTask"
        },
        {
          "id": "delete_nonexistent_task",
          "name": "Attempt to delete a non-existent task",
          "description": "Checks behavior when attempting to delete a task id not present in state but api.deleteTask succeeds.",
          "type": "negative",
          "test_setup": {
            "given": "A tasks state with no task having id=999. api.deleteTask is mocked to resolve successfully.",
            "when": "handleDeleteTask(999) is called.",
            "then": "The tasks state remains unchanged. No alert is shown."
          },
          "implementation_id": "App_handleDeleteTask"
        },
        {
          "id": "delete_task_api_failure",
          "name": "API failure during task deletion",
          "description": "Ensures that an alert is shown and state is unchanged if api.deleteTask throws an error.",
          "type": "negative",
          "test_setup": {
            "given": "A tasks state containing a task with id=2. api.deleteTask is mocked to throw an error.",
            "when": "handleDeleteTask(2) is called.",
            "then": "The tasks state is unchanged. An alert with message 'Failed to delete task' is shown."
          },
          "implementation_id": "App_handleDeleteTask"
        },
        {
          "id": "delete_task_multiple_tasks",
          "name": "Delete one task from multiple tasks",
          "description": "Verifies that only the specified task is removed and others remain unaffected.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks state with tasks [{id: 1}, {id: 2}, {id: 3}]. api.deleteTask is mocked to resolve successfully.",
            "when": "handleDeleteTask(2) is called.",
            "then": "The tasks state contains [{id: 1}, {id: 3}]. No alert is shown."
          },
          "implementation_id": "App_handleDeleteTask"
        },
        {
          "id": "delete_task_empty_state",
          "name": "Attempt to delete from empty tasks state",
          "description": "Checks that deleting from an empty state does not throw and no alert is shown if api.deleteTask succeeds.",
          "type": "negative",
          "test_setup": {
            "given": "An empty tasks state. api.deleteTask is mocked to resolve successfully.",
            "when": "handleDeleteTask(1) is called.",
            "then": "The tasks state remains empty. No alert is shown."
          },
          "implementation_id": "App_handleDeleteTask"
        },
        {
          "id": "delete_task_api_slow_response",
          "name": "API slow response during deletion",
          "description": "Ensures correct behavior if api.deleteTask resolves after a delay.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks state with a task id=5. api.deleteTask is mocked to resolve after a delay.",
            "when": "handleDeleteTask(5) is called.",
            "then": "The task with id=5 is eventually removed from the tasks state. No alert is shown."
          },
          "implementation_id": "App_handleDeleteTask"
        },
        {
          "id": "delete_task_api_failure_nonexistent",
          "name": "API failure when deleting non-existent task",
          "description": "Ensures alert is shown if api.deleteTask fails even when the task is not in state.",
          "type": "negative",
          "test_setup": {
            "given": "A tasks state with no task id=123. api.deleteTask is mocked to throw an error.",
            "when": "handleDeleteTask(123) is called.",
            "then": "The tasks state is unchanged. An alert with message 'Failed to delete task' is shown."
          },
          "implementation_id": "App_handleDeleteTask"
        },
        {
          "id": "delete_task_invalid_id_type",
          "name": "Delete task with invalid id type",
          "description": "Checks behavior when handleDeleteTask is called with an invalid id type (e.g., string instead of number).",
          "type": "negative",
          "test_setup": {
            "given": "A tasks state with tasks [{id: 1}]. api.deleteTask is mocked to throw a type error.",
            "when": "handleDeleteTask('invalid') is called.",
            "then": "The tasks state is unchanged. An alert with message 'Failed to delete task' is shown."
          },
          "implementation_id": "App_handleDeleteTask"
        }
      ]
    },
    {
      "implementation_id": "api_deleteTask",
      "test_cases": [
        {
          "id": "deleteTask_valid_id_success",
          "name": "Delete task with valid ID (success)",
          "description": "Should successfully delete a task when a valid task ID is provided and the backend responds with OK.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task ID exists and the backend is reachable.",
            "when": "deleteTask(valid_id) is called.",
            "then": "The function completes without throwing an error."
          },
          "implementation_id": "api_deleteTask"
        },
        {
          "id": "deleteTask_nonexistent_id_error",
          "name": "Delete task with non-existent ID (backend returns not found)",
          "description": "Should throw an error when attempting to delete a task with an ID that does not exist (backend returns 404).",
          "type": "negative",
          "test_setup": {
            "given": "A task ID that does not exist in the backend.",
            "when": "deleteTask(nonexistent_id) is called.",
            "then": "The function throws an error with the message 'Failed to delete task'."
          },
          "implementation_id": "api_deleteTask"
        },
        {
          "id": "deleteTask_backend_error",
          "name": "Delete task when backend returns server error",
          "description": "Should throw an error when the backend returns a 500 Internal Server Error.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and the backend is configured to return a 500 error.",
            "when": "deleteTask(valid_id) is called.",
            "then": "The function throws an error with the message 'Failed to delete task'."
          },
          "implementation_id": "api_deleteTask"
        },
        {
          "id": "deleteTask_network_failure",
          "name": "Delete task with network failure",
          "description": "Should throw an error when there is a network failure during the DELETE request.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and the network is unavailable or the request times out.",
            "when": "deleteTask(valid_id) is called.",
            "then": "The function throws an error (network-related or 'Failed to delete task')."
          },
          "implementation_id": "api_deleteTask"
        },
        {
          "id": "deleteTask_invalid_id_type",
          "name": "Delete task with invalid ID type",
          "description": "Should throw an error or fail gracefully when the provided ID is not a valid type (e.g., null, undefined, empty string, or object).",
          "type": "negative",
          "test_setup": {
            "given": "An invalid ID value (null, undefined, empty string, or object).",
            "when": "deleteTask(invalid_id) is called.",
            "then": "The function throws an error or fails gracefully, not making a DELETE request."
          },
          "implementation_id": "api_deleteTask"
        },
        {
          "id": "deleteTask_id_as_zero",
          "name": "Delete task with ID as zero (boundary condition)",
          "description": "Should handle the case where the task ID is zero, which may be a boundary value depending on backend implementation.",
          "type": "negative",
          "test_setup": {
            "given": "A task ID of 0 (zero).",
            "when": "deleteTask(0) is called.",
            "then": "The function throws an error if the backend does not allow zero as a valid ID, or completes if zero is valid."
          },
          "implementation_id": "api_deleteTask"
        },
        {
          "id": "deleteTask_id_as_negative",
          "name": "Delete task with negative ID (boundary condition)",
          "description": "Should handle the case where the task ID is negative, which is typically invalid.",
          "type": "negative",
          "test_setup": {
            "given": "A task ID of -1 (negative value).",
            "when": "deleteTask(-1) is called.",
            "then": "The function throws an error if the backend does not allow negative IDs."
          },
          "implementation_id": "api_deleteTask"
        },
        {
          "id": "deleteTask_id_as_large_number",
          "name": "Delete task with very large ID (boundary condition)",
          "description": "Should handle the case where the task ID is a very large number, testing backend and function limits.",
          "type": "negative",
          "test_setup": {
            "given": "A task ID with a very large integer value (e.g., 999999999999).",
            "when": "deleteTask(large_id) is called.",
            "then": "The function throws an error if the backend does not allow such IDs, or completes if the ID is valid."
          },
          "implementation_id": "api_deleteTask"
        },
        {
          "id": "deleteTask_id_as_string_number",
          "name": "Delete task with ID as stringified number",
          "description": "Should handle the case where the task ID is a string that represents a number.",
          "type": "negative",
          "test_setup": {
            "given": "A task ID as a string (e.g., '123').",
            "when": "deleteTask('123') is called.",
            "then": "The function throws an error or completes depending on backend type coercion."
          },
          "implementation_id": "api_deleteTask"
        },
        {
          "id": "deleteTask_id_as_special_characters",
          "name": "Delete task with ID containing special characters",
          "description": "Should handle the case where the task ID contains special characters, which may cause backend errors.",
          "type": "negative",
          "test_setup": {
            "given": "A task ID with special characters (e.g., '!@#$%').",
            "when": "deleteTask('!@#$%') is called.",
            "then": "The function throws an error if the backend rejects the ID."
          },
          "implementation_id": "api_deleteTask"
        }
      ]
    },
    {
      "implementation_id": "database_delete_task",
      "test_cases": [
        {
          "id": "delete_existing_task",
          "name": "Delete an existing task",
          "description": "Deletes a task that exists in the persistent storage. Should return True and remove the task.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file containing a task with id '123'.",
            "when": "delete_task('123') is called.",
            "then": "The function returns True and the task with id '123' is no longer present in tasks.json."
          },
          "implementation_id": "database_delete_task"
        },
        {
          "id": "delete_nonexistent_task",
          "name": "Attempt to delete a non-existent task",
          "description": "Attempts to delete a task that does not exist. Should return False and not modify the tasks list.",
          "type": "negative",
          "test_setup": {
            "given": "A tasks.json file containing tasks, none with id '999'.",
            "when": "delete_task('999') is called.",
            "then": "The function returns False and tasks.json remains unchanged."
          },
          "implementation_id": "database_delete_task"
        },
        {
          "id": "delete_task_empty_list",
          "name": "Delete from empty task list",
          "description": "Attempts to delete a task when the tasks list is empty. Should return False.",
          "type": "negative",
          "test_setup": {
            "given": "A tasks.json file that is empty (no tasks).",
            "when": "delete_task('1') is called.",
            "then": "The function returns False and tasks.json remains empty."
          },
          "implementation_id": "database_delete_task"
        },
        {
          "id": "delete_task_multiple_same_id",
          "name": "Delete when multiple tasks have the same id",
          "description": "Deletes a task when multiple tasks have the same id. Should remove all tasks with that id and return True.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file containing two tasks with id '42'.",
            "when": "delete_task('42') is called.",
            "then": "The function returns True and no tasks with id '42' remain in tasks.json."
          },
          "implementation_id": "database_delete_task"
        },
        {
          "id": "delete_task_id_type_int",
          "name": "Delete task with integer id",
          "description": "Deletes a task where the id is stored as an integer. Should handle type correctly and remove the task.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file containing a task with id 7 (integer).",
            "when": "delete_task(7) is called.",
            "then": "The function returns True and the task with id 7 is removed."
          },
          "implementation_id": "database_delete_task"
        },
        {
          "id": "delete_task_id_type_str",
          "name": "Delete task with string id",
          "description": "Deletes a task where the id is stored as a string. Should handle type correctly and remove the task.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file containing a task with id '7' (string).",
            "when": "delete_task('7') is called.",
            "then": "The function returns True and the task with id '7' is removed."
          },
          "implementation_id": "database_delete_task"
        },
        {
          "id": "delete_task_invalid_id_type",
          "name": "Delete task with invalid id type",
          "description": "Attempts to delete a task with an invalid id type (e.g., None or object). Should return False or raise an appropriate error.",
          "type": "negative",
          "test_setup": {
            "given": "A tasks.json file containing valid tasks.",
            "when": "delete_task(None) is called.",
            "then": "The function returns False or raises a TypeError, and tasks.json remains unchanged."
          },
          "implementation_id": "database_delete_task"
        },
        {
          "id": "delete_task_persistence",
          "name": "Persistence after deletion",
          "description": "Ensures that after a successful deletion, the tasks.json file is updated and persists the change.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file containing a task with id 'abc'.",
            "when": "delete_task('abc') is called.",
            "then": "The function returns True and tasks.json does not contain the task with id 'abc' after reloading."
          },
          "implementation_id": "database_delete_task"
        },
        {
          "id": "delete_task_file_missing",
          "name": "Delete when tasks.json is missing",
          "description": "Attempts to delete a task when the tasks.json file does not exist. Should handle the error gracefully.",
          "type": "negative",
          "test_setup": {
            "given": "No tasks.json file exists.",
            "when": "delete_task('1') is called.",
            "then": "The function returns False or raises a FileNotFoundError."
          },
          "implementation_id": "database_delete_task"
        },
        {
          "id": "delete_task_corrupted_file",
          "name": "Delete when tasks.json is corrupted",
          "description": "Attempts to delete a task when tasks.json contains invalid JSON. Should handle the error gracefully.",
          "type": "negative",
          "test_setup": {
            "given": "A tasks.json file with invalid/corrupted JSON content.",
            "when": "delete_task('1') is called.",
            "then": "The function raises a JSONDecodeError or returns False."
          },
          "implementation_id": "database_delete_task"
        }
      ]
    },
    {
      "implementation_id": "App_handleToggleComplete",
      "test_cases": [
        {
          "id": "toggle_complete_success",
          "name": "Toggle task completion status successfully",
          "description": "Should toggle the completed status of a task and reload the task list when the API call succeeds.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with completed: false and a mocked api.updateTask that resolves successfully.",
            "when": "handleToggleComplete(task) is called.",
            "then": "api.updateTask is called with the task id and completed: true, and the task list is reloaded."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_incomplete_success",
          "name": "Toggle task to incomplete successfully",
          "description": "Should toggle the completed status of a completed task back to incomplete and reload the task list when the API call succeeds.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with completed: true and a mocked api.updateTask that resolves successfully.",
            "when": "handleToggleComplete(task) is called.",
            "then": "api.updateTask is called with the task id and completed: false, and the task list is reloaded."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_api_failure",
          "name": "API failure when toggling completion",
          "description": "Should show an alert if the API call to update the task fails.",
          "type": "negative",
          "test_setup": {
            "given": "A task object and a mocked api.updateTask that rejects with an error.",
            "when": "handleToggleComplete(task) is called.",
            "then": "An alert with the message 'Failed to update task status' is shown and the task list is not reloaded."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_null_task",
          "name": "Handle null or undefined task input",
          "description": "Should handle gracefully if the input task is null or undefined.",
          "type": "negative",
          "test_setup": {
            "given": "A null or undefined task object.",
            "when": "handleToggleComplete(task) is called.",
            "then": "The function does not throw an uncaught error and shows an alert or logs an error."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_missing_id",
          "name": "Handle task with missing id",
          "description": "Should handle gracefully if the task object does not have an id property.",
          "type": "negative",
          "test_setup": {
            "given": "A task object without an id property.",
            "when": "handleToggleComplete(task) is called.",
            "then": "The function does not throw an uncaught error and shows an alert or logs an error."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_already_updated",
          "name": "Toggle task that is already in desired state",
          "description": "Should still call the API and reload tasks even if the task is already in the desired completed state.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with completed: true and the user attempts to mark it as completed again.",
            "when": "handleToggleComplete(task) is called.",
            "then": "api.updateTask is called with completed: false, and the task list is reloaded."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_network_latency",
          "name": "Handle network latency during API call",
          "description": "Should not reload the task list until the API call resolves, even if there is network latency.",
          "type": "positive",
          "test_setup": {
            "given": "A task object and a mocked api.updateTask that resolves after a delay.",
            "when": "handleToggleComplete(task) is called.",
            "then": "The task list is reloaded only after the API call completes."
          },
          "implementation_id": "App_handleToggleComplete"
        },
        {
          "id": "toggle_multiple_calls",
          "name": "Multiple rapid toggles",
          "description": "Should handle multiple rapid toggles of the same task without causing inconsistent state.",
          "type": "negative",
          "test_setup": {
            "given": "A task object and a mocked api.updateTask that resolves successfully.",
            "when": "handleToggleComplete(task) is called multiple times rapidly.",
            "then": "api.updateTask is called for each toggle, and the task list is reloaded after each successful call."
          },
          "implementation_id": "App_handleToggleComplete"
        }
      ]
    },
    {
      "implementation_id": "api_updateTask",
      "test_cases": [
        {
          "id": "update_completed_true_success",
          "name": "Update task to completed successfully",
          "description": "Should successfully update a task's completed status to true and return the updated task.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task ID and a task object with completed: true",
            "when": "api.updateTask(id, { ...task, completed: true }) is called",
            "then": "The backend responds with 200 OK and the updated task object is returned"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "update_completed_false_success",
          "name": "Update task to pending successfully",
          "description": "Should successfully update a task's completed status to false and return the updated task.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task ID and a task object with completed: false",
            "when": "api.updateTask(id, { ...task, completed: false }) is called",
            "then": "The backend responds with 200 OK and the updated task object is returned"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "update_other_fields_success",
          "name": "Update other fields of a task",
          "description": "Should update other fields (e.g., title, description) along with completed status.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task ID and a task object with updated title, description, and completed: true",
            "when": "api.updateTask(id, updatedTask) is called",
            "then": "The backend responds with 200 OK and the updated task object is returned"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "invalid_task_id",
          "name": "Update with invalid task ID",
          "description": "Should throw an error if the task ID does not exist.",
          "type": "negative",
          "test_setup": {
            "given": "An invalid or non-existent task ID and a valid task object",
            "when": "api.updateTask(invalidId, task) is called",
            "then": "The backend responds with 404 Not Found and the function throws an error"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "missing_completed_field",
          "name": "Update without completed field",
          "description": "Should throw an error if the completed field is missing in the task object.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and a task object missing the completed field",
            "when": "api.updateTask(id, taskWithoutCompleted) is called",
            "then": "The backend responds with 400 Bad Request or similar and the function throws an error"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "backend_error_500",
          "name": "Backend returns 500 error",
          "description": "Should throw an error if the backend returns a 500 Internal Server Error.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and a valid task object",
            "when": "api.updateTask(id, task) is called and backend returns 500",
            "then": "The function throws an error"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "network_failure",
          "name": "Network failure during update",
          "description": "Should throw an error if there is a network failure during the request.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and a valid task object",
            "when": "api.updateTask(id, task) is called and the network is unavailable",
            "then": "The function throws an error"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "empty_task_object",
          "name": "Update with empty task object",
          "description": "Should throw an error if the task object is empty.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and an empty task object {}",
            "when": "api.updateTask(id, {}) is called",
            "then": "The backend responds with 400 Bad Request or similar and the function throws an error"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "malformed_task_object",
          "name": "Update with malformed task object",
          "description": "Should throw an error if the task object contains invalid fields or types.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and a task object with invalid field types (e.g., completed: 'yes')",
            "when": "api.updateTask(id, malformedTask) is called",
            "then": "The backend responds with 400 Bad Request or similar and the function throws an error"
          },
          "implementation_id": "api_updateTask"
        },
        {
          "id": "unauthorized_update",
          "name": "Unauthorized update attempt",
          "description": "Should throw an error if the user is not authorized to update the task.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task ID and a valid task object, but the user is not authenticated or authorized",
            "when": "api.updateTask(id, task) is called",
            "then": "The backend responds with 401 Unauthorized or 403 Forbidden and the function throws an error"
          },
          "implementation_id": "api_updateTask"
        }
      ]
    },
    {
      "implementation_id": "database_update_task",
      "test_cases": [
        {
          "id": "update_existing_task_completed_true",
          "name": "Update existing task to completed",
          "description": "Update an existing task's completed field to True and verify the update is persisted.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file with a task having id=1 and completed=False.",
            "when": "update_task(1, TaskUpdate(completed=True)) is called.",
            "then": "The returned task has completed=True, and tasks.json is updated accordingly."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_existing_task_completed_false",
          "name": "Update existing task to pending",
          "description": "Update an existing task's completed field to False and verify the update is persisted.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file with a task having id=2 and completed=True.",
            "when": "update_task(2, TaskUpdate(completed=False)) is called.",
            "then": "The returned task has completed=False, and tasks.json is updated accordingly."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_existing_task_other_fields",
          "name": "Update other fields of an existing task",
          "description": "Update fields other than 'completed' (e.g., title, description) and verify the update.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file with a task having id=3, title='Old Title'.",
            "when": "update_task(3, TaskUpdate(title='New Title')) is called.",
            "then": "The returned task has title='New Title', and tasks.json is updated accordingly."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_nonexistent_task",
          "name": "Update non-existent task",
          "description": "Attempt to update a task that does not exist in tasks.json.",
          "type": "negative",
          "test_setup": {
            "given": "A tasks.json file with tasks having ids 1, 2, 3.",
            "when": "update_task(999, TaskUpdate(completed=True)) is called.",
            "then": "The function returns None and tasks.json remains unchanged."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_task_empty_tasks_list",
          "name": "Update task when tasks list is empty",
          "description": "Attempt to update a task when tasks.json is empty.",
          "type": "negative",
          "test_setup": {
            "given": "An empty tasks.json file.",
            "when": "update_task(1, TaskUpdate(completed=True)) is called.",
            "then": "The function returns None and tasks.json remains empty."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_task_partial_update",
          "name": "Partial update of a task",
          "description": "Update only one field of a task and verify other fields remain unchanged.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file with a task having id=4, title='Task 4', completed=False.",
            "when": "update_task(4, TaskUpdate(completed=True)) is called.",
            "then": "The returned task has completed=True, title remains 'Task 4', and tasks.json is updated accordingly."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_task_invalid_update_data",
          "name": "Update task with invalid update data",
          "description": "Attempt to update a task with invalid data (e.g., invalid field type).",
          "type": "negative",
          "test_setup": {
            "given": "A tasks.json file with a task having id=5.",
            "when": "update_task(5, TaskUpdate(completed='not_a_boolean')) is called.",
            "then": "The function raises a validation error or returns None, and tasks.json remains unchanged."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_task_multiple_tasks",
          "name": "Update one task among multiple tasks",
          "description": "Update a specific task in a list of multiple tasks and verify only the targeted task is updated.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file with tasks having ids 6, 7, 8. Task 7 has completed=False.",
            "when": "update_task(7, TaskUpdate(completed=True)) is called.",
            "then": "Only task 7 is updated to completed=True, other tasks remain unchanged."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_task_id_type_mismatch",
          "name": "Update task with id type mismatch",
          "description": "Attempt to update a task using a task_id of a different type (e.g., string instead of int).",
          "type": "negative",
          "test_setup": {
            "given": "A tasks.json file with a task having id=9 (int).",
            "when": "update_task('9', TaskUpdate(completed=True)) is called.",
            "then": "The function returns None or raises a type error, and tasks.json remains unchanged."
          },
          "implementation_id": "database_update_task"
        },
        {
          "id": "update_task_no_changes",
          "name": "Update task with no changes",
          "description": "Call update_task with an empty update (no fields changed) and verify behavior.",
          "type": "positive",
          "test_setup": {
            "given": "A tasks.json file with a task having id=10, completed=False.",
            "when": "update_task(10, TaskUpdate()) is called.",
            "then": "The returned task is unchanged, and tasks.json remains the same."
          },
          "implementation_id": "database_update_task"
        }
      ]
    },
    {
      "implementation_id": "backend.models.Category_enum",
      "test_cases": [
        {
          "id": "category_enum_valid_members",
          "name": "test_enum_has_all_defined_categories",
          "description": "Verify that the Category enum contains all required members: 'Work', 'Personal', and 'Study'.",
          "type": "positive",
          "test_setup": {
            "given": "The Category enum is defined in backend/models.py.",
            "when": "The enum members are inspected.",
            "then": "The enum contains 'work', 'personal', and 'study' with values 'Work', 'Personal', and 'Study' respectively."
          },
          "implementation_id": "backend.models.Category_enum"
        },
        {
          "id": "category_enum_value_access",
          "name": "test_enum_value_access",
          "description": "Verify that each Category enum member returns the correct string value.",
          "type": "positive",
          "test_setup": {
            "given": "The Category enum is defined.",
            "when": "Each member's value is accessed (Category.work, Category.personal, Category.study).",
            "then": "The values returned are 'Work', 'Personal', and 'Study' respectively."
          },
          "implementation_id": "backend.models.Category_enum"
        },
        {
          "id": "category_enum_from_value_valid",
          "name": "test_enum_from_value_valid",
          "description": "Verify that the enum can be instantiated from valid string values.",
          "type": "positive",
          "test_setup": {
            "given": "The Category enum is defined.",
            "when": "Category('Work'), Category('Personal'), and Category('Study') are called.",
            "then": "The corresponding enum members are returned without error."
          },
          "implementation_id": "backend.models.Category_enum"
        },
        {
          "id": "category_enum_from_value_invalid",
          "name": "test_enum_from_value_invalid",
          "description": "Verify that instantiating the enum with an invalid value raises a ValueError.",
          "type": "negative",
          "test_setup": {
            "given": "The Category enum is defined.",
            "when": "Category('Leisure') is called.",
            "then": "A ValueError is raised indicating 'Leisure' is not a valid Category."
          },
          "implementation_id": "backend.models.Category_enum"
        },
        {
          "id": "category_enum_case_sensitivity",
          "name": "test_enum_case_sensitivity",
          "description": "Verify that the enum is case-sensitive and does not accept values with incorrect casing.",
          "type": "negative",
          "test_setup": {
            "given": "The Category enum is defined.",
            "when": "Category('work'), Category('personal'), or Category('study') are called with lowercase values.",
            "then": "A ValueError is raised for each case."
          },
          "implementation_id": "backend.models.Category_enum"
        },
        {
          "id": "category_enum_member_iteration",
          "name": "test_enum_member_iteration",
          "description": "Verify that iterating over the Category enum yields all defined members.",
          "type": "positive",
          "test_setup": {
            "given": "The Category enum is defined.",
            "when": "The enum is iterated over.",
            "then": "All three members ('work', 'personal', 'study') are yielded."
          },
          "implementation_id": "backend.models.Category_enum"
        },
        {
          "id": "category_enum_uniqueness",
          "name": "test_enum_member_uniqueness",
          "description": "Verify that all enum members have unique values.",
          "type": "positive",
          "test_setup": {
            "given": "The Category enum is defined.",
            "when": "The values of all members are compared.",
            "then": "Each value ('Work', 'Personal', 'Study') is unique."
          },
          "implementation_id": "backend.models.Category_enum"
        },
        {
          "id": "category_enum_invalid_type",
          "name": "test_enum_invalid_type",
          "description": "Verify that passing a non-string type to the enum raises a TypeError or ValueError.",
          "type": "negative",
          "test_setup": {
            "given": "The Category enum is defined.",
            "when": "Category(123) or Category(None) is called.",
            "then": "A TypeError or ValueError is raised."
          },
          "implementation_id": "backend.models.Category_enum"
        },
        {
          "id": "category_enum_str_and_repr",
          "name": "test_enum_str_and_repr",
          "description": "Verify that str() and repr() of enum members return expected representations.",
          "type": "positive",
          "test_setup": {
            "given": "The Category enum is defined.",
            "when": "str(Category.work) and repr(Category.work) are called.",
            "then": "str(Category.work) returns 'Work', repr(Category.work) returns 'Category.work' or similar."
          },
          "implementation_id": "backend.models.Category_enum"
        }
      ]
    },
    {
      "implementation_id": "backend.models.TaskBase_model",
      "test_cases": [
        {
          "id": "taskbase_valid_all_fields",
          "name": "test_valid_taskbase_all_fields",
          "description": "Create a TaskBase instance with all fields provided, including a valid category.",
          "type": "positive",
          "test_setup": {
            "given": "title='Finish report', description='Complete the annual report', priority=Priority.HIGH, category=Category.WORK, due_date=date(2026, 1, 10), completed=False",
            "when": "TaskBase is instantiated with all fields",
            "then": "A TaskBase instance is created with the provided values"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_valid_required_fields_only",
          "name": "test_valid_taskbase_required_fields_only",
          "description": "Create a TaskBase instance with only required fields (title, priority, completed).",
          "type": "positive",
          "test_setup": {
            "given": "title='Read book', priority=Priority.LOW, completed=True",
            "when": "TaskBase is instantiated with only required fields",
            "then": "A TaskBase instance is created with optional fields set to None"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_optional_category_none",
          "name": "test_taskbase_optional_category_none",
          "description": "Create a TaskBase instance with category explicitly set to None.",
          "type": "positive",
          "test_setup": {
            "given": "title='Plan trip', priority=Priority.MEDIUM, completed=False, category=None",
            "when": "TaskBase is instantiated with category=None",
            "then": "A TaskBase instance is created with category as None"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_optional_description_none",
          "name": "test_taskbase_optional_description_none",
          "description": "Create a TaskBase instance with description explicitly set to None.",
          "type": "positive",
          "test_setup": {
            "given": "title='Buy groceries', priority=Priority.LOW, completed=False, description=None",
            "when": "TaskBase is instantiated with description=None",
            "then": "A TaskBase instance is created with description as None"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_optional_due_date_none",
          "name": "test_taskbase_optional_due_date_none",
          "description": "Create a TaskBase instance with due_date explicitly set to None.",
          "type": "positive",
          "test_setup": {
            "given": "title='Clean house', priority=Priority.MEDIUM, completed=False, due_date=None",
            "when": "TaskBase is instantiated with due_date=None",
            "then": "A TaskBase instance is created with due_date as None"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_empty_title",
          "name": "test_taskbase_empty_title",
          "description": "Attempt to create a TaskBase instance with an empty string for title.",
          "type": "negative",
          "test_setup": {
            "given": "title='', priority=Priority.HIGH, completed=False",
            "when": "TaskBase is instantiated with an empty title",
            "then": "ValidationError is raised due to empty title"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_missing_title",
          "name": "test_taskbase_missing_title",
          "description": "Attempt to create a TaskBase instance without providing a title.",
          "type": "negative",
          "test_setup": {
            "given": "priority=Priority.HIGH, completed=False",
            "when": "TaskBase is instantiated without a title",
            "then": "ValidationError is raised due to missing required field 'title'"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_invalid_priority",
          "name": "test_taskbase_invalid_priority",
          "description": "Attempt to create a TaskBase instance with an invalid priority value.",
          "type": "negative",
          "test_setup": {
            "given": "title='Test', priority='URGENT', completed=False",
            "when": "TaskBase is instantiated with an invalid priority",
            "then": "ValidationError is raised due to invalid enum value for priority"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_invalid_category",
          "name": "test_taskbase_invalid_category",
          "description": "Attempt to create a TaskBase instance with an invalid category value.",
          "type": "negative",
          "test_setup": {
            "given": "title='Test', priority=Priority.LOW, completed=False, category='LEISURE'",
            "when": "TaskBase is instantiated with an invalid category",
            "then": "ValidationError is raised due to invalid enum value for category"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_missing_priority",
          "name": "test_taskbase_missing_priority",
          "description": "Attempt to create a TaskBase instance without providing a priority.",
          "type": "negative",
          "test_setup": {
            "given": "title='Test', completed=False",
            "when": "TaskBase is instantiated without a priority",
            "then": "ValidationError is raised due to missing required field 'priority'"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_missing_completed",
          "name": "test_taskbase_missing_completed",
          "description": "Attempt to create a TaskBase instance without providing the completed field.",
          "type": "negative",
          "test_setup": {
            "given": "title='Test', priority=Priority.HIGH",
            "when": "TaskBase is instantiated without completed",
            "then": "ValidationError is raised due to missing required field 'completed'"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_invalid_due_date_type",
          "name": "test_taskbase_invalid_due_date_type",
          "description": "Attempt to create a TaskBase instance with a non-date value for due_date.",
          "type": "negative",
          "test_setup": {
            "given": "title='Test', priority=Priority.LOW, completed=False, due_date='2026-01-10'",
            "when": "TaskBase is instantiated with due_date as a string",
            "then": "ValidationError is raised due to invalid type for due_date"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_invalid_completed_type",
          "name": "test_taskbase_invalid_completed_type",
          "description": "Attempt to create a TaskBase instance with a non-boolean value for completed.",
          "type": "negative",
          "test_setup": {
            "given": "title='Test', priority=Priority.LOW, completed='yes'",
            "when": "TaskBase is instantiated with completed as a string",
            "then": "ValidationError is raised due to invalid type for completed"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_long_title",
          "name": "test_taskbase_long_title",
          "description": "Create a TaskBase instance with a very long title to test boundary conditions.",
          "type": "positive",
          "test_setup": {
            "given": "title='A'*256, priority=Priority.MEDIUM, completed=False",
            "when": "TaskBase is instantiated with a 256-character title",
            "then": "A TaskBase instance is created if title length is allowed"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_special_characters_title",
          "name": "test_taskbase_special_characters_title",
          "description": "Create a TaskBase instance with special characters in the title.",
          "type": "positive",
          "test_setup": {
            "given": "title='!@#$%^&*()_+-=[]{}|;:,.<>?/~`', priority=Priority.LOW, completed=True",
            "when": "TaskBase is instantiated with special characters in title",
            "then": "A TaskBase instance is created with the special character title"
          },
          "implementation_id": "backend.models.TaskBase_model"
        },
        {
          "id": "taskbase_null_description",
          "name": "test_taskbase_null_description",
          "description": "Create a TaskBase instance with description set to None.",
          "type": "positive",
          "test_setup": {
            "given": "title='Null description', priority=Priority.HIGH, completed=False, description=None",
            "when": "TaskBase is instantiated with description=None",
            "then": "A TaskBase instance is created with description as None"
          },
          "implementation_id": "backend.models.TaskBase_model"
        }
      ]
    },
    {
      "implementation_id": "frontend.api.Task_interface",
      "test_cases": [
        {
          "id": "task_valid_all_fields",
          "name": "Valid Task with All Fields",
          "description": "Verify that a Task object with all fields, including a valid category, is accepted.",
          "type": "positive",
          "test_setup": {
            "given": "A Task object with id, title, description, priority='High', category='Work', due_date, completed=false",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is accepted and category is correctly handled as 'Work'"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_valid_without_optional_fields",
          "name": "Valid Task Without Optional Fields",
          "description": "Verify that a Task object without optional fields (description, category, due_date) is accepted.",
          "type": "positive",
          "test_setup": {
            "given": "A Task object with id, title, priority='Low', completed=true (no description, category, due_date)",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is accepted and optional fields are undefined"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_valid_with_each_category",
          "name": "Valid Task with Each Category Value",
          "description": "Verify that a Task object is accepted for each valid category value: 'Work', 'Personal', 'Study'.",
          "type": "positive",
          "test_setup": {
            "given": "A Task object with category set to each allowed value in turn",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is accepted and category is correctly handled"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_valid_without_category",
          "name": "Valid Task Without Category",
          "description": "Verify that a Task object without the category field is accepted.",
          "type": "positive",
          "test_setup": {
            "given": "A Task object with no category field",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is accepted and category is undefined"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_invalid_category_value",
          "name": "Invalid Category Value",
          "description": "Verify that a Task object with an invalid category value is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "A Task object with category='Shopping' (not in allowed values)",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is rejected with a validation error for category"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_category_null",
          "name": "Category Field Null",
          "description": "Verify that a Task object with category set to null is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "A Task object with category=null",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is rejected with a validation error for category"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_category_empty_string",
          "name": "Category Field Empty String",
          "description": "Verify that a Task object with category set to an empty string is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "A Task object with category=''",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is rejected with a validation error for category"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_missing_required_fields",
          "name": "Missing Required Fields",
          "description": "Verify that a Task object missing required fields (id, title, priority, completed) is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "A Task object missing one or more required fields",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is rejected with a validation error for missing fields"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_priority_invalid_value",
          "name": "Invalid Priority Value",
          "description": "Verify that a Task object with an invalid priority value is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "A Task object with priority='Urgent' (not in allowed values)",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is rejected with a validation error for priority"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_due_date_format",
          "name": "Due Date Format Validation",
          "description": "Verify that a Task object with an invalid due_date format is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "A Task object with due_date='31-12-2025' (not ISO string)",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is rejected with a validation error for due_date"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_completed_boolean_type",
          "name": "Completed Field Non-Boolean",
          "description": "Verify that a Task object with completed set to a non-boolean value is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "A Task object with completed='yes' (string instead of boolean)",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is rejected with a validation error for completed"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_id_empty_string",
          "name": "ID Field Empty String",
          "description": "Verify that a Task object with id set to an empty string is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "A Task object with id=''",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is rejected with a validation error for id"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_title_empty_string",
          "name": "Title Field Empty String",
          "description": "Verify that a Task object with title set to an empty string is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "A Task object with title=''",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is rejected with a validation error for title"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_description_optional",
          "name": "Description Field Optional",
          "description": "Verify that a Task object with and without the description field is accepted.",
          "type": "positive",
          "test_setup": {
            "given": "A Task object with and without the description field",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is accepted in both cases"
          },
          "implementation_id": "frontend.api.Task_interface"
        },
        {
          "id": "task_category_case_sensitivity",
          "name": "Category Field Case Sensitivity",
          "description": "Verify that a Task object with category value in incorrect case (e.g., 'work') is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "A Task object with category='work' (lowercase)",
            "when": "The Task object is created and passed to the API/UI",
            "then": "The Task is rejected with a validation error for category"
          },
          "implementation_id": "frontend.api.Task_interface"
        }
      ]
    },
    {
      "implementation_id": "frontend.api.TaskCreate_interface",
      "test_cases": [
        {
          "id": "tc_positive_all_fields_valid",
          "name": "Create task with all valid fields and category",
          "description": "Verify that a task is created successfully when all required and optional fields, including a valid category, are provided.",
          "type": "positive",
          "test_setup": {
            "given": "title: 'Finish report', description: 'Complete the annual report', priority: 'High', category: 'Work', due_date: '2026-01-10', completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Task is accepted and category is set to 'Work'"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_positive_category_omitted",
          "name": "Create task without category",
          "description": "Verify that a task can be created without specifying the optional category field.",
          "type": "positive",
          "test_setup": {
            "given": "title: 'Read book', priority: 'Low', completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Task is accepted and category is undefined or handled as uncategorized"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_positive_category_personal",
          "name": "Create task with category 'Personal'",
          "description": "Verify that a task can be created with the category set to 'Personal'.",
          "type": "positive",
          "test_setup": {
            "given": "title: 'Call mom', priority: 'Medium', category: 'Personal', completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Task is accepted and category is set to 'Personal'"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_positive_category_study",
          "name": "Create task with category 'Study'",
          "description": "Verify that a task can be created with the category set to 'Study'.",
          "type": "positive",
          "test_setup": {
            "given": "title: 'Review math notes', priority: 'Medium', category: 'Study', completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Task is accepted and category is set to 'Study'"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_positive_minimum_required_fields",
          "name": "Create task with only required fields",
          "description": "Verify that a task can be created when only the required fields are provided.",
          "type": "positive",
          "test_setup": {
            "given": "title: 'Buy groceries', priority: 'Low', completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Task is accepted and optional fields are undefined"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_negative_invalid_category",
          "name": "Create task with invalid category value",
          "description": "Verify that a task with an invalid category value is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "title: 'Plan trip', priority: 'Medium', category: 'Travel', completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Validation error is returned for invalid category"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_negative_missing_title",
          "name": "Create task missing required title",
          "description": "Verify that a task without the required title field is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "priority: 'High', completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Validation error is returned for missing title"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_negative_missing_priority",
          "name": "Create task missing required priority",
          "description": "Verify that a task without the required priority field is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "title: 'Do laundry', completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Validation error is returned for missing priority"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_negative_invalid_priority",
          "name": "Create task with invalid priority value",
          "description": "Verify that a task with an invalid priority value is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "title: 'Clean room', priority: 'Urgent', completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Validation error is returned for invalid priority"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_negative_missing_completed",
          "name": "Create task missing required completed field",
          "description": "Verify that a task without the required completed field is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "title: 'Pay bills', priority: 'High'",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Validation error is returned for missing completed"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_negative_invalid_due_date_format",
          "name": "Create task with invalid due_date format",
          "description": "Verify that a task with an invalid due_date string is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "title: 'Dentist appointment', priority: 'Medium', due_date: '32-13-2026', completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Validation error is returned for invalid due_date format"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_negative_empty_title",
          "name": "Create task with empty title",
          "description": "Verify that a task with an empty string as the title is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "title: '', priority: 'Low', completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Validation error is returned for empty title"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_positive_description_omitted",
          "name": "Create task without description",
          "description": "Verify that a task can be created without the optional description field.",
          "type": "positive",
          "test_setup": {
            "given": "title: 'Exercise', priority: 'Medium', completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Task is accepted and description is undefined"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_positive_due_date_omitted",
          "name": "Create task without due_date",
          "description": "Verify that a task can be created without the optional due_date field.",
          "type": "positive",
          "test_setup": {
            "given": "title: 'Meditate', priority: 'Low', completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Task is accepted and due_date is undefined"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        },
        {
          "id": "tc_negative_category_null",
          "name": "Create task with category set to null",
          "description": "Verify that a task with category explicitly set to null is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "title: 'Yoga', priority: 'Medium', category: null, completed: false",
            "when": "TaskCreate interface is used to send this object to the backend",
            "then": "Validation error is returned for category being null"
          },
          "implementation_id": "frontend.api.TaskCreate_interface"
        }
      ]
    },
    {
      "implementation_id": "backend.test_api.test_api_function",
      "test_cases": [
        {
          "id": "test_create_task_with_category_positive",
          "name": "Create Task with Valid Category",
          "description": "Verify that a task can be created with a valid category ('Work') and is returned by the API.",
          "type": "positive",
          "test_setup": {
            "given": "A valid task payload with category 'Work'.",
            "when": "POST /tasks is called with the payload.",
            "then": "The response status is 201 Created, and the returned task includes the 'Work' category."
          },
          "implementation_id": "backend.test_api.test_api_function"
        },
        {
          "id": "test_get_tasks_after_creation_positive",
          "name": "Get Tasks After Creation",
          "description": "Verify that the created task with category 'Work' is present in the task list.",
          "type": "positive",
          "test_setup": {
            "given": "A task with category 'Work' has been created.",
            "when": "GET /tasks is called.",
            "then": "The response contains the created task with the correct category."
          },
          "implementation_id": "backend.test_api.test_api_function"
        },
        {
          "id": "test_update_task_category_positive",
          "name": "Update Task Category",
          "description": "Verify that updating a task's category via PUT is successful and reflected in subsequent GET.",
          "type": "positive",
          "test_setup": {
            "given": "A task with category 'Work' exists.",
            "when": "PUT /tasks/{id} is called to change the category to 'Personal'.",
            "then": "The response status is 200 OK, and GET /tasks shows the updated category."
          },
          "implementation_id": "backend.test_api.test_api_function"
        },
        {
          "id": "test_delete_task_positive",
          "name": "Delete Task",
          "description": "Verify that deleting a task removes it from the task list.",
          "type": "positive",
          "test_setup": {
            "given": "A task exists in the system.",
            "when": "DELETE /tasks/{id} is called.",
            "then": "The response status is 204 No Content, and GET /tasks no longer returns the deleted task."
          },
          "implementation_id": "backend.test_api.test_api_function"
        },
        {
          "id": "test_create_task_with_invalid_category_negative",
          "name": "Create Task with Invalid Category",
          "description": "Verify that creating a task with an invalid category is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "A task payload with an invalid category (e.g., 'InvalidCategory').",
            "when": "POST /tasks is called with the payload.",
            "then": "The response status is 400 Bad Request, and an error message is returned."
          },
          "implementation_id": "backend.test_api.test_api_function"
        },
        {
          "id": "test_update_task_with_invalid_category_negative",
          "name": "Update Task with Invalid Category",
          "description": "Verify that updating a task to an invalid category is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "A valid task exists.",
            "when": "PUT /tasks/{id} is called with an invalid category.",
            "then": "The response status is 400 Bad Request, and the task's category remains unchanged."
          },
          "implementation_id": "backend.test_api.test_api_function"
        },
        {
          "id": "test_get_nonexistent_task_negative",
          "name": "Get Nonexistent Task",
          "description": "Verify that requesting a nonexistent task returns a 404 error.",
          "type": "negative",
          "test_setup": {
            "given": "No task exists with the specified ID.",
            "when": "GET /tasks/{nonexistent_id} is called.",
            "then": "The response status is 404 Not Found."
          },
          "implementation_id": "backend.test_api.test_api_function"
        },
        {
          "id": "test_update_nonexistent_task_negative",
          "name": "Update Nonexistent Task",
          "description": "Verify that updating a nonexistent task returns a 404 error.",
          "type": "negative",
          "test_setup": {
            "given": "No task exists with the specified ID.",
            "when": "PUT /tasks/{nonexistent_id} is called.",
            "then": "The response status is 404 Not Found."
          },
          "implementation_id": "backend.test_api.test_api_function"
        },
        {
          "id": "test_delete_nonexistent_task_negative",
          "name": "Delete Nonexistent Task",
          "description": "Verify that deleting a nonexistent task returns a 404 error.",
          "type": "negative",
          "test_setup": {
            "given": "No task exists with the specified ID.",
            "when": "DELETE /tasks/{nonexistent_id} is called.",
            "then": "The response status is 404 Not Found."
          },
          "implementation_id": "backend.test_api.test_api_function"
        },
        {
          "id": "test_create_task_without_category_edge",
          "name": "Create Task Without Category",
          "description": "Verify that creating a task without specifying a category is handled correctly (either default or error).",
          "type": "negative",
          "test_setup": {
            "given": "A task payload without a category field.",
            "when": "POST /tasks is called.",
            "then": "The response status is 400 Bad Request (if category is required) or the task is created with a default category."
          },
          "implementation_id": "backend.test_api.test_api_function"
        },
        {
          "id": "test_create_task_with_empty_category_edge",
          "name": "Create Task with Empty Category",
          "description": "Verify that creating a task with an empty string as category is handled correctly.",
          "type": "negative",
          "test_setup": {
            "given": "A task payload with category set to an empty string.",
            "when": "POST /tasks is called.",
            "then": "The response status is 400 Bad Request, and an error message is returned."
          },
          "implementation_id": "backend.test_api.test_api_function"
        },
        {
          "id": "test_create_task_with_long_category_edge",
          "name": "Create Task with Excessively Long Category",
          "description": "Verify that creating a task with a category exceeding the maximum allowed length is rejected.",
          "type": "negative",
          "test_setup": {
            "given": "A task payload with a category string longer than allowed (e.g., 256+ characters).",
            "when": "POST /tasks is called.",
            "then": "The response status is 400 Bad Request, and an error message is returned."
          },
          "implementation_id": "backend.test_api.test_api_function"
        }
      ]
    }
  ],
  "component": [
    {
      "implementation_id": "TaskItem_handleDelete",
      "test_cases": [
        {
          "id": "delete_confirm_positive",
          "name": "Delete task after user confirms",
          "description": "Ensures that when the Delete button is clicked and the user confirms the dialog, the onDelete callback is called with the correct task id.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem is rendered with a valid task id and a mock onDelete function.",
            "when": "User clicks the Delete button and confirms the confirmation dialog.",
            "then": "onDelete is called once with the correct task id."
          },
          "implementation_id": "TaskItem_handleDelete"
        },
        {
          "id": "delete_cancel_negative",
          "name": "Cancel deletion when user declines confirmation",
          "description": "Ensures that if the user cancels the confirmation dialog, the onDelete callback is not called.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem is rendered with a valid task id and a mock onDelete function.",
            "when": "User clicks the Delete button and cancels the confirmation dialog.",
            "then": "onDelete is not called."
          },
          "implementation_id": "TaskItem_handleDelete"
        },
        {
          "id": "delete_button_render_positive",
          "name": "Delete button is rendered",
          "description": "Checks that the Delete button is present in the TaskItem component.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem is rendered with required props.",
            "when": "Component is mounted.",
            "then": "Delete button is visible in the DOM."
          },
          "implementation_id": "TaskItem_handleDelete"
        },
        {
          "id": "delete_multiple_clicks_negative",
          "name": "Multiple rapid clicks only trigger one confirmation",
          "description": "Ensures that rapidly clicking the Delete button does not open multiple confirmation dialogs or call onDelete multiple times.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem is rendered with a mock onDelete function.",
            "when": "User rapidly clicks the Delete button multiple times.",
            "then": "Only one confirmation dialog appears and onDelete is called at most once if confirmed."
          },
          "implementation_id": "TaskItem_handleDelete"
        },
        {
          "id": "delete_onDelete_missing_negative",
          "name": "Graceful handling if onDelete is undefined",
          "description": "Checks that the component does not throw an error if onDelete prop is missing and user confirms deletion.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem is rendered without the onDelete prop.",
            "when": "User clicks the Delete button and confirms the dialog.",
            "then": "No error is thrown and the component remains stable."
          },
          "implementation_id": "TaskItem_handleDelete"
        },
        {
          "id": "delete_invalid_task_id_negative",
          "name": "Handle invalid or missing task id",
          "description": "Ensures that if the task id is undefined or invalid, onDelete is called with undefined or the invalid value, but no crash occurs.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem is rendered with an undefined or invalid task id and a mock onDelete.",
            "when": "User clicks the Delete button and confirms the dialog.",
            "then": "onDelete is called with undefined or the invalid id, and the component does not crash."
          },
          "implementation_id": "TaskItem_handleDelete"
        },
        {
          "id": "delete_accessibility_positive",
          "name": "Delete button is accessible via keyboard",
          "description": "Ensures that the Delete button can be focused and activated using keyboard navigation.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem is rendered.",
            "when": "User tabs to the Delete button and presses Enter or Space.",
            "then": "Confirmation dialog appears as expected."
          },
          "implementation_id": "TaskItem_handleDelete"
        },
        {
          "id": "delete_dialog_text_positive",
          "name": "Confirmation dialog displays correct message",
          "description": "Checks that the confirmation dialog shows the expected message when Delete is clicked.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem is rendered.",
            "when": "User clicks the Delete button.",
            "then": "A confirmation dialog with the correct message is displayed."
          },
          "implementation_id": "TaskItem_handleDelete"
        }
      ]
    },
    {
      "implementation_id": "TaskItem_onToggleComplete",
      "test_cases": [
        {
          "id": "taskitem_render_completed",
          "name": "renders_undo_button_for_completed_task",
          "description": "Ensures that when a task is marked as completed, the button label is 'Undo', uses ghost style, and has the correct title.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: true",
            "when": "Component is rendered",
            "then": "Button label is 'Undo', button uses ghost style, and title is 'Mark as pending'"
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "taskitem_render_pending",
          "name": "renders_done_button_for_pending_task",
          "description": "Ensures that when a task is not completed, the button label is 'Done', uses primary style, and has the correct title.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: false",
            "when": "Component is rendered",
            "then": "Button label is 'Done', button uses primary style, and title is 'Mark as completed'"
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "taskitem_toggle_complete_from_pending",
          "name": "calls_onToggleComplete_when_done_clicked",
          "description": "Verifies that clicking the 'Done' button for a pending task calls onToggleComplete with the correct task object.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: false and a mock onToggleComplete",
            "when": "User clicks the 'Done' button",
            "then": "onToggleComplete is called once with the task as argument"
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "taskitem_toggle_complete_from_completed",
          "name": "calls_onToggleComplete_when_undo_clicked",
          "description": "Verifies that clicking the 'Undo' button for a completed task calls onToggleComplete with the correct task object.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop with completed: true and a mock onToggleComplete",
            "when": "User clicks the 'Undo' button",
            "then": "onToggleComplete is called once with the task as argument"
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "taskitem_no_task_prop",
          "name": "does_not_render_button_without_task",
          "description": "Checks that the component handles missing task prop gracefully and does not render the button.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem is rendered without a task prop",
            "when": "Component is rendered",
            "then": "No button is rendered and no error is thrown"
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "taskitem_null_onToggleComplete",
          "name": "handles_null_onToggleComplete_callback",
          "description": "Ensures that if onToggleComplete is null or undefined, clicking the button does not throw an error.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem receives a valid task prop but onToggleComplete is undefined",
            "when": "User clicks the button",
            "then": "No error is thrown and nothing happens"
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "taskitem_multiple_clicks",
          "name": "multiple_clicks_call_onToggleComplete_multiple_times",
          "description": "Verifies that clicking the button multiple times calls onToggleComplete the same number of times.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a valid task prop and a mock onToggleComplete",
            "when": "User clicks the button three times",
            "then": "onToggleComplete is called three times with the task as argument each time"
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "taskitem_button_accessibility",
          "name": "button_has_accessible_title",
          "description": "Ensures the button always has an accessible title attribute reflecting the action.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a task prop (completed true or false)",
            "when": "Component is rendered",
            "then": "Button has a title attribute: 'Mark as pending' if completed, 'Mark as completed' if not"
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "taskitem_task_object_mutation",
          "name": "does_not_mutate_task_object",
          "description": "Ensures that clicking the button does not mutate the original task object passed as prop.",
          "type": "negative",
          "test_setup": {
            "given": "TaskItem receives a task prop and a mock onToggleComplete",
            "when": "User clicks the button",
            "then": "The original task object remains unchanged after the click"
          },
          "implementation_id": "TaskItem_onToggleComplete"
        },
        {
          "id": "taskitem_button_disabled_state",
          "name": "button_is_enabled_by_default",
          "description": "Checks that the button is enabled by default and can be interacted with.",
          "type": "positive",
          "test_setup": {
            "given": "TaskItem receives a valid task prop",
            "when": "Component is rendered",
            "then": "Button is not disabled and can be clicked"
          },
          "implementation_id": "TaskItem_onToggleComplete"
        }
      ]
    },
    {
      "implementation_id": "frontend.components.TaskForm_component",
      "test_cases": [
        {
          "id": "renders_all_fields",
          "name": "Render all form fields",
          "description": "Ensures the TaskForm renders all required input fields and the category dropdown with correct options.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered with default props",
            "when": "Component mounts",
            "then": "Title, description, priority, category, and due date fields are visible; category dropdown contains options: None, Work, Personal, Study"
          },
          "implementation_id": "frontend.components.TaskForm_component"
        },
        {
          "id": "submit_with_all_fields_filled",
          "name": "Submit with all fields filled",
          "description": "Submits the form with all fields filled, including a selected category, and verifies onSubmit is called with correct data.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered; user fills all fields (title, description, priority, category: 'Work', due date)",
            "when": "User clicks submit",
            "then": "onSubmit is called with all field values, including category: 'Work'"
          },
          "implementation_id": "frontend.components.TaskForm_component"
        },
        {
          "id": "submit_with_category_none",
          "name": "Submit with category set to None",
          "description": "Submits the form with category set to 'None' and verifies category is passed as undefined.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered; user fills all fields but selects category: 'None'",
            "when": "User clicks submit",
            "then": "onSubmit is called with category: undefined"
          },
          "implementation_id": "frontend.components.TaskForm_component"
        },
        {
          "id": "submit_with_empty_fields",
          "name": "Submit with empty required fields",
          "description": "Attempts to submit the form with required fields (e.g., title) left empty and expects validation errors.",
          "type": "negative",
          "test_setup": {
            "given": "TaskForm is rendered; user leaves title field empty",
            "when": "User clicks submit",
            "then": "Form displays validation error for title; onSubmit is not called"
          },
          "implementation_id": "frontend.components.TaskForm_component"
        },
        {
          "id": "category_dropdown_options",
          "name": "Category dropdown options",
          "description": "Verifies the category dropdown contains exactly the expected options.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered",
            "when": "User opens the category dropdown",
            "then": "Dropdown shows options: None, Work, Personal, Study"
          },
          "implementation_id": "frontend.components.TaskForm_component"
        },
        {
          "id": "edit_mode_prefills_fields",
          "name": "Edit mode pre-fills fields",
          "description": "When editing an existing task, the form fields are pre-filled with the task's data, including the correct category.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered with initialValues prop containing a task with category: 'Personal'",
            "when": "Component mounts",
            "then": "All fields, including category dropdown, are pre-filled with the task's values"
          },
          "implementation_id": "frontend.components.TaskForm_component"
        },
        {
          "id": "change_category_and_submit",
          "name": "Change category and submit",
          "description": "User changes the category from one value to another and submits; verifies onSubmit receives the updated category.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered with initial category: 'Work'",
            "when": "User changes category to 'Study' and submits",
            "then": "onSubmit is called with category: 'Study'"
          },
          "implementation_id": "frontend.components.TaskForm_component"
        },
        {
          "id": "submit_with_invalid_due_date",
          "name": "Submit with invalid due date",
          "description": "Attempts to submit the form with an invalid due date and expects validation error.",
          "type": "negative",
          "test_setup": {
            "given": "TaskForm is rendered; user enters an invalid due date (e.g., non-date string)",
            "when": "User clicks submit",
            "then": "Form displays validation error for due date; onSubmit is not called"
          },
          "implementation_id": "frontend.components.TaskForm_component"
        },
        {
          "id": "submit_with_no_category_field",
          "name": "Submit with no category field present",
          "description": "Ensures robustness if the category field is programmatically removed or not rendered.",
          "type": "negative",
          "test_setup": {
            "given": "TaskForm is rendered with category dropdown missing (simulated edge case)",
            "when": "User fills other fields and submits",
            "then": "onSubmit is called with category: undefined"
          },
          "implementation_id": "frontend.components.TaskForm_component"
        },
        {
          "id": "rapid_category_selection",
          "name": "Rapid category selection changes",
          "description": "User rapidly changes the category selection before submitting; verifies the last selected value is submitted.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered",
            "when": "User quickly selects 'Work', then 'Personal', then 'Study', then submits",
            "then": "onSubmit is called with category: 'Study'"
          },
          "implementation_id": "frontend.components.TaskForm_component"
        },
        {
          "id": "submit_with_whitespace_category",
          "name": "Submit with whitespace category",
          "description": "User tries to submit with a category value that is only whitespace; expects it to be treated as undefined.",
          "type": "negative",
          "test_setup": {
            "given": "TaskForm is rendered; user manipulates category input to be whitespace",
            "when": "User clicks submit",
            "then": "onSubmit is called with category: undefined"
          },
          "implementation_id": "frontend.components.TaskForm_component"
        },
        {
          "id": "form_reset_clears_category",
          "name": "Form reset clears category selection",
          "description": "After submitting or resetting, the category dropdown resets to 'None'.",
          "type": "positive",
          "test_setup": {
            "given": "TaskForm is rendered; user selects 'Work' and submits or clicks reset",
            "when": "Form is reset",
            "then": "Category dropdown value is 'None'"
          },
          "implementation_id": "frontend.components.TaskForm_component"
        }
      ]
    },
    {
      "implementation_id": "frontend.components.TaskItem_component",
      "test_cases": [
        {
          "id": "renders_task_with_category_badge",
          "name": "Render Task with Category Badge",
          "description": "Ensures that when a task has a category, the category badge is rendered with the correct label.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with a non-empty 'category' property (e.g., category: 'Work').",
            "when": "The TaskItem component is rendered.",
            "then": "A badge displaying the category name ('Work') is present in the DOM."
          },
          "implementation_id": "frontend.components.TaskItem_component"
        },
        {
          "id": "renders_task_without_category_badge",
          "name": "Render Task without Category Badge",
          "description": "Ensures that when a task does not have a category, the category badge is not rendered.",
          "type": "negative",
          "test_setup": {
            "given": "A task object with an empty or undefined 'category' property.",
            "when": "The TaskItem component is rendered.",
            "then": "No category badge is present in the DOM."
          },
          "implementation_id": "frontend.components.TaskItem_component"
        },
        {
          "id": "renders_priority_badge_correctly",
          "name": "Render Priority Badge",
          "description": "Checks that the priority badge is rendered with the correct class and label based on the task's priority.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with priority set to 'High', 'Medium', or 'Low'.",
            "when": "The TaskItem component is rendered.",
            "then": "A badge with the correct class ('badge-high', 'badge-medium', or 'badge-low') and label is present."
          },
          "implementation_id": "frontend.components.TaskItem_component"
        },
        {
          "id": "renders_task_title_and_description",
          "name": "Render Task Title and Description",
          "description": "Ensures the task title and description are rendered correctly.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with 'title' and 'description' properties.",
            "when": "The TaskItem component is rendered.",
            "then": "The title and description are visible in the DOM."
          },
          "implementation_id": "frontend.components.TaskItem_component"
        },
        {
          "id": "renders_due_date_if_present",
          "name": "Render Due Date",
          "description": "Checks that the due date is rendered if present in the task.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with a valid 'due_date' property.",
            "when": "The TaskItem component is rendered.",
            "then": "The due date is displayed in the format returned by toLocaleDateString()."
          },
          "implementation_id": "frontend.components.TaskItem_component"
        },
        {
          "id": "does_not_render_due_date_if_absent",
          "name": "No Due Date Rendered",
          "description": "Ensures that if the due date is not present, nothing is rendered for due date.",
          "type": "negative",
          "test_setup": {
            "given": "A task object without a 'due_date' property.",
            "when": "The TaskItem component is rendered.",
            "then": "No due date is displayed in the DOM."
          },
          "implementation_id": "frontend.components.TaskItem_component"
        },
        {
          "id": "toggle_complete_button_changes_state",
          "name": "Toggle Complete Button",
          "description": "Checks that clicking the complete button calls onToggleComplete with the correct task.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with completed: false and a mock onToggleComplete handler.",
            "when": "The 'Done' button is clicked.",
            "then": "onToggleComplete is called with the task object."
          },
          "implementation_id": "frontend.components.TaskItem_component"
        },
        {
          "id": "edit_button_triggers_onEdit",
          "name": "Edit Button Functionality",
          "description": "Checks that clicking the edit button calls onEdit with the correct task.",
          "type": "positive",
          "test_setup": {
            "given": "A task object and a mock onEdit handler.",
            "when": "The 'Edit' button is clicked.",
            "then": "onEdit is called with the task object."
          },
          "implementation_id": "frontend.components.TaskItem_component"
        },
        {
          "id": "delete_button_confirms_and_triggers_onDelete",
          "name": "Delete Button Confirmation and Action",
          "description": "Checks that clicking the delete button shows a confirmation dialog and calls onDelete if confirmed.",
          "type": "positive",
          "test_setup": {
            "given": "A task object and a mock onDelete handler. window.confirm is mocked to return true.",
            "when": "The 'Delete' button is clicked.",
            "then": "window.confirm is called and onDelete is called with the task id."
          },
          "implementation_id": "frontend.components.TaskItem_component"
        },
        {
          "id": "delete_button_cancels_on_cancel",
          "name": "Delete Button Cancel",
          "description": "Checks that clicking the delete button does not call onDelete if the confirmation is cancelled.",
          "type": "negative",
          "test_setup": {
            "given": "A task object and a mock onDelete handler. window.confirm is mocked to return false.",
            "when": "The 'Delete' button is clicked.",
            "then": "window.confirm is called and onDelete is not called."
          },
          "implementation_id": "frontend.components.TaskItem_component"
        },
        {
          "id": "completed_task_renders_with_opacity_and_line_through",
          "name": "Completed Task Visuals",
          "description": "Ensures that a completed task is rendered with reduced opacity and a line-through on the title.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with completed: true.",
            "when": "The TaskItem component is rendered.",
            "then": "The card has reduced opacity and the title has a line-through style."
          },
          "implementation_id": "frontend.components.TaskItem_component"
        },
        {
          "id": "edge_case_empty_title_and_category",
          "name": "Edge Case: Empty Title and Category",
          "description": "Checks rendering when the task has an empty string for title and category.",
          "type": "negative",
          "test_setup": {
            "given": "A task object with title: '' and category: ''.",
            "when": "The TaskItem component is rendered.",
            "then": "No category badge is rendered and the title area is empty but present."
          },
          "implementation_id": "frontend.components.TaskItem_component"
        },
        {
          "id": "edge_case_long_category_name",
          "name": "Edge Case: Long Category Name",
          "description": "Ensures that a very long category name is rendered without breaking the layout.",
          "type": "positive",
          "test_setup": {
            "given": "A task object with a very long string for category.",
            "when": "The TaskItem component is rendered.",
            "then": "The category badge displays the full string and the layout remains intact (no overflow or breakage)."
          },
          "implementation_id": "frontend.components.TaskItem_component"
        }
      ]
    },
    {
      "implementation_id": "App.filteredTasks_sorting",
      "test_cases": [
        {
          "id": "sort_due_date_all_present",
          "name": "Sorts tasks by due date when all tasks have due dates",
          "description": "Ensures tasks are sorted in ascending order by due date when all tasks have valid due_date fields and sortOption is 'dueDate'.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id:1, due_date:'2026-01-05'}, {id:2, due_date:'2026-01-03'}, {id:3, due_date:'2026-01-04'}], sortOption = 'dueDate', statusFilter = 'all'",
            "when": "Component renders or sortOption is changed to 'dueDate'",
            "then": "Tasks are rendered in order: id 2, id 3, id 1"
          },
          "implementation_id": "App.filteredTasks_sorting"
        },
        {
          "id": "sort_due_date_missing_dates",
          "name": "Sorts tasks by due date with missing due_date fields",
          "description": "Tasks without a due_date should appear after those with a due_date when sorting by due date.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id:1, due_date:'2026-01-05'}, {id:2}, {id:3, due_date:'2026-01-04'}], sortOption = 'dueDate', statusFilter = 'all'",
            "when": "Component renders or sortOption is changed to 'dueDate'",
            "then": "Tasks are rendered in order: id 3, id 1, id 2"
          },
          "implementation_id": "App.filteredTasks_sorting"
        },
        {
          "id": "sort_due_date_all_missing",
          "name": "Sorts tasks by due date when all due_date fields are missing",
          "description": "If all tasks are missing due_date, the original order should be preserved.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id:1}, {id:2}, {id:3}], sortOption = 'dueDate', statusFilter = 'all'",
            "when": "Component renders or sortOption is changed to 'dueDate'",
            "then": "Tasks are rendered in original order: id 1, id 2, id 3"
          },
          "implementation_id": "App.filteredTasks_sorting"
        },
        {
          "id": "sort_priority_all_present",
          "name": "Sorts tasks by priority when all tasks have priority",
          "description": "Tasks are sorted by priority: High first, then Medium, then Low.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id:1, priority:'Low'}, {id:2, priority:'High'}, {id:3, priority:'Medium'}], sortOption = 'priority', statusFilter = 'all'",
            "when": "Component renders or sortOption is changed to 'priority'",
            "then": "Tasks are rendered in order: id 2, id 3, id 1"
          },
          "implementation_id": "App.filteredTasks_sorting"
        },
        {
          "id": "sort_priority_missing_priority",
          "name": "Sorts tasks by priority with missing priority fields",
          "description": "Tasks with missing priority should be treated as lowest priority and appear last.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id:1, priority:'High'}, {id:2}, {id:3, priority:'Low'}], sortOption = 'priority', statusFilter = 'all'",
            "when": "Component renders or sortOption is changed to 'priority'",
            "then": "Tasks are rendered in order: id 1, id 3, id 2"
          },
          "implementation_id": "App.filteredTasks_sorting"
        },
        {
          "id": "sort_priority_invalid_priority",
          "name": "Sorts tasks by priority with invalid priority values",
          "description": "Tasks with invalid priority values should be treated as lowest priority and appear last.",
          "type": "negative",
          "test_setup": {
            "given": "tasks = [{id:1, priority:'High'}, {id:2, priority:'Urgent'}, {id:3, priority:'Low'}], sortOption = 'priority', statusFilter = 'all'",
            "when": "Component renders or sortOption is changed to 'priority'",
            "then": "Tasks are rendered in order: id 1, id 3, id 2"
          },
          "implementation_id": "App.filteredTasks_sorting"
        },
        {
          "id": "sort_none",
          "name": "No sorting applied when sortOption is neither 'dueDate' nor 'priority'",
          "description": "If sortOption is not 'dueDate' or 'priority', the original order is preserved.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id:1}, {id:2}, {id:3}], sortOption = 'none', statusFilter = 'all'",
            "when": "Component renders or sortOption is changed to 'none'",
            "then": "Tasks are rendered in original order: id 1, id 2, id 3"
          },
          "implementation_id": "App.filteredTasks_sorting"
        },
        {
          "id": "filter_status_completed",
          "name": "Filters tasks by completed status",
          "description": "Only completed tasks are shown when statusFilter is 'completed', and sorting is applied to the filtered list.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id:1, completed:true, due_date:'2026-01-05'}, {id:2, completed:false, due_date:'2026-01-03'}, {id:3, completed:true, due_date:'2026-01-04'}], sortOption = 'dueDate', statusFilter = 'completed'",
            "when": "Component renders or statusFilter is changed to 'completed'",
            "then": "Tasks are rendered in order: id 3, id 1"
          },
          "implementation_id": "App.filteredTasks_sorting"
        },
        {
          "id": "filter_status_pending",
          "name": "Filters tasks by pending status",
          "description": "Only pending tasks are shown when statusFilter is 'pending', and sorting is applied to the filtered list.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id:1, completed:true, due_date:'2026-01-05'}, {id:2, completed:false, due_date:'2026-01-03'}, {id:3, completed:false, due_date:'2026-01-04'}], sortOption = 'dueDate', statusFilter = 'pending'",
            "when": "Component renders or statusFilter is changed to 'pending'",
            "then": "Tasks are rendered in order: id 2, id 3"
          },
          "implementation_id": "App.filteredTasks_sorting"
        },
        {
          "id": "empty_tasks_list",
          "name": "Handles empty tasks list",
          "description": "Component should render no tasks and not throw errors when the tasks list is empty.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [], sortOption = 'dueDate', statusFilter = 'all'",
            "when": "Component renders",
            "then": "No tasks are rendered"
          },
          "implementation_id": "App.filteredTasks_sorting"
        },
        {
          "id": "all_tasks_filtered_out",
          "name": "Handles all tasks filtered out by status",
          "description": "If no tasks match the status filter, the component should render no tasks and not throw errors.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id:1, completed:true}], sortOption = 'dueDate', statusFilter = 'pending'",
            "when": "Component renders or statusFilter is changed to 'pending'",
            "then": "No tasks are rendered"
          },
          "implementation_id": "App.filteredTasks_sorting"
        },
        {
          "id": "sort_due_date_invalid_date",
          "name": "Handles invalid due_date values gracefully",
          "description": "Tasks with invalid due_date values should be treated as missing and placed after valid dates.",
          "type": "negative",
          "test_setup": {
            "given": "tasks = [{id:1, due_date:'invalid-date'}, {id:2, due_date:'2026-01-03'}], sortOption = 'dueDate', statusFilter = 'all'",
            "when": "Component renders or sortOption is changed to 'dueDate'",
            "then": "Tasks are rendered in order: id 2, id 1"
          },
          "implementation_id": "App.filteredTasks_sorting"
        },
        {
          "id": "sort_priority_case_insensitive",
          "name": "Sorts tasks by priority case-insensitively",
          "description": "Priority sorting should be case-insensitive (e.g., 'high', 'High', 'HIGH' are equivalent).",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id:1, priority:'high'}, {id:2, priority:'Medium'}, {id:3, priority:'LOW'}], sortOption = 'priority', statusFilter = 'all'",
            "when": "Component renders or sortOption is changed to 'priority'",
            "then": "Tasks are rendered in order: id 1, id 2, id 3"
          },
          "implementation_id": "App.filteredTasks_sorting"
        },
        {
          "id": "sort_option_switching",
          "name": "Switching sort options updates task order",
          "description": "Changing the sort option from 'dueDate' to 'priority' (or vice versa) updates the rendered order of tasks accordingly.",
          "type": "positive",
          "test_setup": {
            "given": "tasks = [{id:1, due_date:'2026-01-05', priority:'Low'}, {id:2, due_date:'2026-01-03', priority:'High'}], sortOption = 'dueDate', statusFilter = 'all'",
            "when": "User changes sortOption to 'priority'",
            "then": "Tasks are rendered in order: id 2, id 1"
          },
          "implementation_id": "App.filteredTasks_sorting"
        }
      ]
    },
    {
      "implementation_id": "App.sortOption_select",
      "test_cases": [
        {
          "id": "sort_dropdown_renders_options",
          "name": "Render Sort Options",
          "description": "Verifies that the select dropdown renders with both 'Sort by Due Date' and 'Sort by Priority' options.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered with default state.",
            "when": "No user interaction.",
            "then": "The select element contains options for 'Sort by Due Date' and 'Sort by Priority' with correct values."
          },
          "implementation_id": "App.sortOption_select"
        },
        {
          "id": "sort_dropdown_default_value",
          "name": "Default Selected Option",
          "description": "Checks that the default selected option matches the initial sortOption state.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered with initial sortOption state (e.g., 'dueDate').",
            "when": "No user interaction.",
            "then": "The select element displays 'Sort by Due Date' as selected."
          },
          "implementation_id": "App.sortOption_select"
        },
        {
          "id": "sort_dropdown_change_to_priority",
          "name": "Change Sort Option to Priority",
          "description": "Ensures that selecting 'Sort by Priority' updates the sortOption state and triggers sorting logic.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered with initial sortOption state 'dueDate'.",
            "when": "User selects 'Sort by Priority' from the dropdown.",
            "then": "sortOption state updates to 'priority' and sorting logic is triggered."
          },
          "implementation_id": "App.sortOption_select"
        },
        {
          "id": "sort_dropdown_change_to_due_date",
          "name": "Change Sort Option to Due Date",
          "description": "Ensures that selecting 'Sort by Due Date' updates the sortOption state and triggers sorting logic.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered with initial sortOption state 'priority'.",
            "when": "User selects 'Sort by Due Date' from the dropdown.",
            "then": "sortOption state updates to 'dueDate' and sorting logic is triggered."
          },
          "implementation_id": "App.sortOption_select"
        },
        {
          "id": "sort_dropdown_invalid_value",
          "name": "Handle Invalid Sort Option Value",
          "description": "Tests the component's behavior when an invalid value is set for the select element.",
          "type": "negative",
          "test_setup": {
            "given": "Component is rendered and select value is programmatically set to an invalid value (e.g., 'invalid').",
            "when": "Component re-renders.",
            "then": "Component either falls back to a default value or displays no selection; no crash or error occurs."
          },
          "implementation_id": "App.sortOption_select"
        },
        {
          "id": "sort_dropdown_no_options",
          "name": "Handle No Options Edge Case",
          "description": "Tests the component's behavior if the options array is empty or undefined.",
          "type": "negative",
          "test_setup": {
            "given": "Component is rendered with an empty or undefined options array (if options are dynamic).",
            "when": "Component renders.",
            "then": "Component displays an empty select or a placeholder; no crash or error occurs."
          },
          "implementation_id": "App.sortOption_select"
        },
        {
          "id": "sort_dropdown_keyboard_navigation",
          "name": "Keyboard Navigation",
          "description": "Ensures the user can navigate and select options using the keyboard.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered and focused.",
            "when": "User uses Tab and Arrow keys to navigate and Enter/Space to select an option.",
            "then": "sortOption state updates according to the selected option."
          },
          "implementation_id": "App.sortOption_select"
        },
        {
          "id": "sort_dropdown_accessibility",
          "name": "Accessibility Attributes",
          "description": "Verifies that the select element has appropriate accessibility attributes (e.g., aria-label).",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered.",
            "when": "No user interaction.",
            "then": "Select element has aria-label or equivalent for screen readers."
          },
          "implementation_id": "App.sortOption_select"
        },
        {
          "id": "sort_dropdown_rapid_selection",
          "name": "Rapid Option Selection",
          "description": "Tests the component's stability when the user rapidly changes the selection multiple times.",
          "type": "positive",
          "test_setup": {
            "given": "Component is rendered.",
            "when": "User quickly alternates between 'Sort by Due Date' and 'Sort by Priority' multiple times.",
            "then": "sortOption state always matches the latest selection; no errors or unexpected behavior."
          },
          "implementation_id": "App.sortOption_select"
        },
        {
          "id": "sort_dropdown_uncontrolled_to_controlled",
          "name": "Uncontrolled to Controlled Transition",
          "description": "Tests the component's behavior if it transitions from uncontrolled to controlled (or vice versa) for the select value.",
          "type": "negative",
          "test_setup": {
            "given": "Component is rendered as uncontrolled, then receives a controlled value prop.",
            "when": "Component re-renders with new props.",
            "then": "No React warning or error; component updates selection as expected."
          },
          "implementation_id": "App.sortOption_select"
        }
      ]
    },
    {
      "implementation_id": "App_function_frontend_src_App_tsx",
      "test_cases": [
        {
          "id": "app_loads_tasks_on_mount",
          "name": "Loads tasks on mount",
          "description": "Verifies that the App component fetches and loads all tasks from the backend when mounted.",
          "type": "positive",
          "test_setup": {
            "given": "App is rendered with an empty initial state.",
            "when": "Component mounts.",
            "then": "loadTasks() is called, backend is queried, and tasks state is populated."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_filters_tasks_by_status_completed",
          "name": "Filters tasks by status: completed",
          "description": "Checks that only completed tasks are shown when the filter is set to 'completed'.",
          "type": "positive",
          "test_setup": {
            "given": "App state contains tasks with mixed statuses.",
            "when": "User selects 'completed' in the status filter.",
            "then": "Only tasks with status 'completed' are displayed."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_filters_tasks_by_status_pending",
          "name": "Filters tasks by status: pending",
          "description": "Checks that only pending tasks are shown when the filter is set to 'pending'.",
          "type": "positive",
          "test_setup": {
            "given": "App state contains tasks with mixed statuses.",
            "when": "User selects 'pending' in the status filter.",
            "then": "Only tasks with status 'pending' are displayed."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_filters_tasks_by_status_all",
          "name": "Filters tasks by status: all",
          "description": "Checks that all tasks are shown when the filter is set to 'all'.",
          "type": "positive",
          "test_setup": {
            "given": "App state contains tasks with mixed statuses.",
            "when": "User selects 'all' in the status filter.",
            "then": "All tasks are displayed."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_sorts_tasks_by_due_date",
          "name": "Sorts tasks by due date",
          "description": "Verifies that tasks are sorted by due date when the sort control is set accordingly.",
          "type": "positive",
          "test_setup": {
            "given": "App state contains tasks with different due dates.",
            "when": "User selects 'due date' in the sort control.",
            "then": "Tasks are displayed in ascending order of due date."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_sorts_tasks_by_priority",
          "name": "Sorts tasks by priority",
          "description": "Verifies that tasks are sorted by priority when the sort control is set accordingly.",
          "type": "positive",
          "test_setup": {
            "given": "App state contains tasks with different priorities.",
            "when": "User selects 'priority' in the sort control.",
            "then": "Tasks are displayed in order of priority (e.g., high to low)."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_renders_loading_state",
          "name": "Renders loading state",
          "description": "Checks that a loading indicator is shown while tasks are being fetched.",
          "type": "positive",
          "test_setup": {
            "given": "Tasks are being fetched from the backend.",
            "when": "App is in loading state.",
            "then": "A loading spinner or message is displayed."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_renders_empty_state",
          "name": "Renders empty state",
          "description": "Checks that an empty state message is shown when there are no tasks.",
          "type": "positive",
          "test_setup": {
            "given": "Tasks state is an empty array.",
            "when": "App renders.",
            "then": "An empty state message (e.g., 'No tasks found') is displayed."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_creates_new_task",
          "name": "Creates a new task",
          "description": "Verifies that submitting the task form adds a new task to the list.",
          "type": "positive",
          "test_setup": {
            "given": "App is rendered and task form is visible.",
            "when": "User fills out the form and submits.",
            "then": "A new task is added to the tasks list and displayed."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_edits_existing_task",
          "name": "Edits an existing task",
          "description": "Verifies that editing a task updates it in the list.",
          "type": "positive",
          "test_setup": {
            "given": "App is rendered with at least one task.",
            "when": "User opens the edit form for a task, modifies fields, and submits.",
            "then": "The task is updated in the tasks list and displayed with new values."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_handles_backend_error_on_load",
          "name": "Handles backend error on load",
          "description": "Checks that an error message is shown if loading tasks from the backend fails.",
          "type": "negative",
          "test_setup": {
            "given": "Backend returns an error when fetching tasks.",
            "when": "App mounts and loadTasks() is called.",
            "then": "An error message is displayed to the user."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_handles_backend_error_on_create",
          "name": "Handles backend error on create",
          "description": "Checks that an error message is shown if creating a new task fails.",
          "type": "negative",
          "test_setup": {
            "given": "App is rendered and task form is visible.",
            "when": "User submits the form and backend returns an error.",
            "then": "An error message is displayed and the task is not added."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_handles_backend_error_on_edit",
          "name": "Handles backend error on edit",
          "description": "Checks that an error message is shown if editing a task fails.",
          "type": "negative",
          "test_setup": {
            "given": "App is rendered with at least one task.",
            "when": "User edits a task and backend returns an error.",
            "then": "An error message is displayed and the task is not updated."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_does_not_search_by_keyword",
          "name": "Does not search by keyword",
          "description": "Verifies that searching by keyword is not implemented and does not filter tasks.",
          "type": "negative",
          "test_setup": {
            "given": "App is rendered with multiple tasks.",
            "when": "User attempts to search by keyword (if any input is present).",
            "then": "No search/filtering by keyword occurs; all tasks remain visible as per status and sort filters."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_filters_with_no_matching_tasks",
          "name": "Filters with no matching tasks",
          "description": "Checks that the empty state is shown when filtering results in no tasks.",
          "type": "positive",
          "test_setup": {
            "given": "App state contains only completed tasks.",
            "when": "User filters by 'pending' status.",
            "then": "No tasks are displayed and the empty state message is shown."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        },
        {
          "id": "app_handles_invalid_task_data",
          "name": "Handles invalid task data",
          "description": "Checks that the component handles invalid or malformed task data gracefully.",
          "type": "negative",
          "test_setup": {
            "given": "Backend returns tasks with missing or invalid fields.",
            "when": "App loads tasks.",
            "then": "Invalid tasks are not rendered, and an error or warning is shown if appropriate."
          },
          "implementation_id": "App_function_frontend_src_App_tsx"
        }
      ]
    }
  ],
  "endpoint": [
    {
      "implementation_id": "backend_delete_task_endpoint",
      "test_cases": [
        {
          "id": "delete_existing_task_success",
          "name": "Delete existing task successfully",
          "description": "Verify that deleting an existing task returns a success message and status 200.",
          "type": "positive",
          "request_method": "DELETE",
          "request_url": "/tasks/1",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 200,
          "response_body_json": "{\"detail\": \"Task deleted successfully\"}",
          "test_setup": {
            "given": "A task with ID 1 exists in the database.",
            "when": "DELETE /tasks/1 is called.",
            "then": "The response status is 200 and the body contains a success message."
          },
          "implementation_id": "backend_delete_task_endpoint"
        },
        {
          "id": "delete_nonexistent_task_404",
          "name": "Delete non-existent task returns 404",
          "description": "Verify that deleting a non-existent task returns a 404 error.",
          "type": "negative",
          "request_method": "DELETE",
          "request_url": "/tasks/9999",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 404,
          "response_body_json": "{\"detail\": \"Task not found\"}",
          "test_setup": {
            "given": "No task with ID 9999 exists in the database.",
            "when": "DELETE /tasks/9999 is called.",
            "then": "The response status is 404 and the body contains 'Task not found'."
          },
          "implementation_id": "backend_delete_task_endpoint"
        },
        {
          "id": "delete_task_invalid_id_string",
          "name": "Delete task with invalid string ID",
          "description": "Verify that deleting a task with a non-integer ID returns a 422 validation error.",
          "type": "negative",
          "request_method": "DELETE",
          "request_url": "/tasks/abc",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 422,
          "response_body_json": "{\"detail\": \"Unprocessable Entity\"}",
          "test_setup": {
            "given": "The API expects an integer task_id.",
            "when": "DELETE /tasks/abc is called.",
            "then": "The response status is 422 and the body indicates a validation error."
          },
          "implementation_id": "backend_delete_task_endpoint"
        },
        {
          "id": "delete_task_invalid_id_negative",
          "name": "Delete task with negative ID",
          "description": "Verify that deleting a task with a negative ID returns a 404 error (assuming negative IDs are invalid).",
          "type": "negative",
          "request_method": "DELETE",
          "request_url": "/tasks/-1",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 404,
          "response_body_json": "{\"detail\": \"Task not found\"}",
          "test_setup": {
            "given": "No task with ID -1 exists in the database.",
            "when": "DELETE /tasks/-1 is called.",
            "then": "The response status is 404 and the body contains 'Task not found'."
          },
          "implementation_id": "backend_delete_task_endpoint"
        },
        {
          "id": "delete_task_id_zero",
          "name": "Delete task with ID zero",
          "description": "Verify that deleting a task with ID 0 returns a 404 error (assuming ID 0 is invalid or not present).",
          "type": "negative",
          "request_method": "DELETE",
          "request_url": "/tasks/0",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 404,
          "response_body_json": "{\"detail\": \"Task not found\"}",
          "test_setup": {
            "given": "No task with ID 0 exists in the database.",
            "when": "DELETE /tasks/0 is called.",
            "then": "The response status is 404 and the body contains 'Task not found'."
          },
          "implementation_id": "backend_delete_task_endpoint"
        },
        {
          "id": "delete_task_twice",
          "name": "Delete the same task twice",
          "description": "Verify that deleting a task twice returns 200 on the first call and 404 on the second.",
          "type": "negative",
          "request_method": "DELETE",
          "request_url": "/tasks/2",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 404,
          "response_body_json": "{\"detail\": \"Task not found\"}",
          "test_setup": {
            "given": "A task with ID 2 exists in the database.",
            "when": "DELETE /tasks/2 is called twice in succession.",
            "then": "The first call returns 200, the second returns 404."
          },
          "implementation_id": "backend_delete_task_endpoint"
        },
        {
          "id": "delete_task_no_auth",
          "name": "Delete task without authentication",
          "description": "Verify that deleting a task without authentication returns 401 if authentication is required.",
          "type": "negative",
          "request_method": "DELETE",
          "request_url": "/tasks/3",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 401,
          "response_body_json": "{\"detail\": \"Not authenticated\"}",
          "test_setup": {
            "given": "Authentication is required and no credentials are provided.",
            "when": "DELETE /tasks/3 is called.",
            "then": "The response status is 401 and the body indicates authentication is required."
          },
          "implementation_id": "backend_delete_task_endpoint"
        }
      ]
    },
    {
      "implementation_id": "backend_update_task_endpoint",
      "test_cases": [
        {
          "id": "update_task_success_completed",
          "name": "Update Task Status to Completed - Success",
          "description": "Successfully update an existing task's status to completed.",
          "type": "positive",
          "request_method": "PUT",
          "request_url": "/tasks/1",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"status\": \"completed\"}",
          "response_status_code": 200,
          "response_body_json": "{\"id\": 1, \"status\": \"completed\"}",
          "test_setup": {
            "given": "A task with id 1 exists and is currently pending.",
            "when": "A PUT request is sent to /tasks/1 with status set to completed.",
            "then": "The response contains the updated task with status completed and status code 200."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_success_pending",
          "name": "Update Task Status to Pending - Success",
          "description": "Successfully update an existing task's status to pending.",
          "type": "positive",
          "request_method": "PUT",
          "request_url": "/tasks/2",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"status\": \"pending\"}",
          "response_status_code": 200,
          "response_body_json": "{\"id\": 2, \"status\": \"pending\"}",
          "test_setup": {
            "given": "A task with id 2 exists and is currently completed.",
            "when": "A PUT request is sent to /tasks/2 with status set to pending.",
            "then": "The response contains the updated task with status pending and status code 200."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_not_found",
          "name": "Update Non-existent Task - Not Found",
          "description": "Attempt to update a task that does not exist should return 404.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/9999",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"status\": \"completed\"}",
          "response_status_code": 404,
          "response_body_json": "{\"detail\": \"Task not found\"}",
          "test_setup": {
            "given": "No task with id 9999 exists.",
            "when": "A PUT request is sent to /tasks/9999.",
            "then": "The response is a 404 error with appropriate error message."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_invalid_status",
          "name": "Update Task with Invalid Status Value",
          "description": "Attempt to update a task with an invalid status value should return 422.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/1",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"status\": \"in_progress\"}",
          "response_status_code": 422,
          "response_body_json": "{\"detail\": \"Invalid status value\"}",
          "test_setup": {
            "given": "A task with id 1 exists.",
            "when": "A PUT request is sent to /tasks/1 with status set to an invalid value.",
            "then": "The response is a 422 error indicating invalid status value."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_missing_status",
          "name": "Update Task with Missing Status Field",
          "description": "Attempt to update a task without providing the status field should return 422.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/1",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{}",
          "response_status_code": 422,
          "response_body_json": "{\"detail\": \"Missing required field: status\"}",
          "test_setup": {
            "given": "A task with id 1 exists.",
            "when": "A PUT request is sent to /tasks/1 with an empty body.",
            "then": "The response is a 422 error indicating missing required field."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_invalid_id_type",
          "name": "Update Task with Non-integer Task ID",
          "description": "Attempt to update a task with a non-integer task_id should return 422.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/abc",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"status\": \"completed\"}",
          "response_status_code": 422,
          "response_body_json": "{\"detail\": \"Invalid task_id type\"}",
          "test_setup": {
            "given": "No task with id 'abc' exists (task_id must be integer).",
            "when": "A PUT request is sent to /tasks/abc.",
            "then": "The response is a 422 error indicating invalid task_id type."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_extra_fields",
          "name": "Update Task with Extra Fields in Body",
          "description": "Update a task with extra fields in the request body should ignore extra fields and update status.",
          "type": "positive",
          "request_method": "PUT",
          "request_url": "/tasks/3",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"status\": \"completed\", \"extra\": \"ignore_me\"}",
          "response_status_code": 200,
          "response_body_json": "{\"id\": 3, \"status\": \"completed\"}",
          "test_setup": {
            "given": "A task with id 3 exists.",
            "when": "A PUT request is sent to /tasks/3 with status and an extra field.",
            "then": "The response contains the updated task and ignores the extra field."
          },
          "implementation_id": "backend_update_task_endpoint"
        },
        {
          "id": "update_task_empty_body",
          "name": "Update Task with Empty Body",
          "description": "Attempt to update a task with an empty request body should return 422.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/1",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "",
          "response_status_code": 422,
          "response_body_json": "{\"detail\": \"Request body cannot be empty\"}",
          "test_setup": {
            "given": "A task with id 1 exists.",
            "when": "A PUT request is sent to /tasks/1 with an empty body.",
            "then": "The response is a 422 error indicating the request body cannot be empty."
          },
          "implementation_id": "backend_update_task_endpoint"
        }
      ]
    },
    {
      "implementation_id": "frontend.api.updateTask_endpoint",
      "test_cases": [
        {
          "id": "update_task_valid_data",
          "name": "Update Task with Valid Data",
          "description": "Successfully updates an existing task with all valid fields including category.",
          "type": "positive",
          "request_method": "PUT",
          "request_url": "/tasks/12345",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"title\":\"Finish report\",\"description\":\"Complete the annual report\",\"dueDate\":\"2026-01-10\",\"category\":\"Work\"}",
          "response_status_code": 200,
          "response_body_json": "{\"id\":\"12345\",\"title\":\"Finish report\",\"description\":\"Complete the annual report\",\"dueDate\":\"2026-01-10\",\"category\":\"Work\"}",
          "test_setup": {
            "given": "A task with id '12345' exists.",
            "when": "A PUT request is sent to /tasks/12345 with valid updated data including category.",
            "then": "The task is updated and the response contains the updated task data."
          },
          "implementation_id": "frontend.api.updateTask_endpoint"
        },
        {
          "id": "update_task_missing_category",
          "name": "Update Task Without Category",
          "description": "Attempts to update a task without providing the category field.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/12345",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"title\":\"Finish report\",\"description\":\"Complete the annual report\",\"dueDate\":\"2026-01-10\"}",
          "response_status_code": 400,
          "response_body_json": "{\"error\":\"Category field is required.\"}",
          "test_setup": {
            "given": "A task with id '12345' exists.",
            "when": "A PUT request is sent to /tasks/12345 without the category field.",
            "then": "The API returns a 400 error indicating the category is required."
          },
          "implementation_id": "frontend.api.updateTask_endpoint"
        },
        {
          "id": "update_task_invalid_category",
          "name": "Update Task with Invalid Category",
          "description": "Attempts to update a task with an invalid category value.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/12345",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"title\":\"Finish report\",\"description\":\"Complete the annual report\",\"dueDate\":\"2026-01-10\",\"category\":\"InvalidCategory\"}",
          "response_status_code": 400,
          "response_body_json": "{\"error\":\"Invalid category value.\"}",
          "test_setup": {
            "given": "A task with id '12345' exists and valid categories are Work, Personal, Study.",
            "when": "A PUT request is sent to /tasks/12345 with an invalid category.",
            "then": "The API returns a 400 error indicating the category is invalid."
          },
          "implementation_id": "frontend.api.updateTask_endpoint"
        },
        {
          "id": "update_task_nonexistent_id",
          "name": "Update Nonexistent Task",
          "description": "Attempts to update a task that does not exist.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/99999",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"title\":\"New Task\",\"description\":\"Desc\",\"dueDate\":\"2026-01-10\",\"category\":\"Work\"}",
          "response_status_code": 404,
          "response_body_json": "{\"error\":\"Task not found.\"}",
          "test_setup": {
            "given": "No task with id '99999' exists.",
            "when": "A PUT request is sent to /tasks/99999.",
            "then": "The API returns a 404 error indicating the task was not found."
          },
          "implementation_id": "frontend.api.updateTask_endpoint"
        },
        {
          "id": "update_task_empty_title",
          "name": "Update Task with Empty Title",
          "description": "Attempts to update a task with an empty title field.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/12345",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"title\":\"\",\"description\":\"Complete the annual report\",\"dueDate\":\"2026-01-10\",\"category\":\"Work\"}",
          "response_status_code": 400,
          "response_body_json": "{\"error\":\"Title cannot be empty.\"}",
          "test_setup": {
            "given": "A task with id '12345' exists.",
            "when": "A PUT request is sent to /tasks/12345 with an empty title.",
            "then": "The API returns a 400 error indicating the title cannot be empty."
          },
          "implementation_id": "frontend.api.updateTask_endpoint"
        },
        {
          "id": "update_task_long_category",
          "name": "Update Task with Excessively Long Category",
          "description": "Attempts to update a task with a category string that exceeds the maximum allowed length.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/12345",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"title\":\"Finish report\",\"description\":\"Complete the annual report\",\"dueDate\":\"2026-01-10\",\"category\":\"ThisCategoryNameIsWayTooLongToBeValidAndShouldFailValidation\"}",
          "response_status_code": 400,
          "response_body_json": "{\"error\":\"Category exceeds maximum length.\"}",
          "test_setup": {
            "given": "A task with id '12345' exists.",
            "when": "A PUT request is sent to /tasks/12345 with an excessively long category.",
            "then": "The API returns a 400 error indicating the category is too long."
          },
          "implementation_id": "frontend.api.updateTask_endpoint"
        },
        {
          "id": "update_task_no_body",
          "name": "Update Task with No Body",
          "description": "Attempts to update a task without providing a request body.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/12345",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "",
          "response_status_code": 400,
          "response_body_json": "{\"error\":\"Request body is required.\"}",
          "test_setup": {
            "given": "A task with id '12345' exists.",
            "when": "A PUT request is sent to /tasks/12345 with no body.",
            "then": "The API returns a 400 error indicating the request body is required."
          },
          "implementation_id": "frontend.api.updateTask_endpoint"
        },
        {
          "id": "update_task_category_boundary",
          "name": "Update Task with Category Boundary Value",
          "description": "Updates a task with a category string at the maximum allowed length.",
          "type": "positive",
          "request_method": "PUT",
          "request_url": "/tasks/12345",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"title\":\"Finish report\",\"description\":\"Complete the annual report\",\"dueDate\":\"2026-01-10\",\"category\":\"12345678901234567890\"}",
          "response_status_code": 200,
          "response_body_json": "{\"id\":\"12345\",\"title\":\"Finish report\",\"description\":\"Complete the annual report\",\"dueDate\":\"2026-01-10\",\"category\":\"12345678901234567890\"}",
          "test_setup": {
            "given": "A task with id '12345' exists and category max length is 20.",
            "when": "A PUT request is sent to /tasks/12345 with a category of exactly 20 characters.",
            "then": "The task is updated and the response contains the updated task data."
          },
          "implementation_id": "frontend.api.updateTask_endpoint"
        },
        {
          "id": "update_task_invalid_json",
          "name": "Update Task with Invalid JSON",
          "description": "Attempts to update a task with a malformed JSON body.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/12345",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"title\":\"Finish report\",\"description\":\"Complete the annual report\",\"dueDate\":\"2026-01-10\",\"category\":\"Work\"",
          "response_status_code": 400,
          "response_body_json": "{\"error\":\"Malformed JSON.\"}",
          "test_setup": {
            "given": "A task with id '12345' exists.",
            "when": "A PUT request is sent to /tasks/12345 with malformed JSON.",
            "then": "The API returns a 400 error indicating malformed JSON."
          },
          "implementation_id": "frontend.api.updateTask_endpoint"
        },
        {
          "id": "update_task_duplicate_title",
          "name": "Update Task with Duplicate Title",
          "description": "Attempts to update a task with a title that already exists for another task in the same category.",
          "type": "negative",
          "request_method": "PUT",
          "request_url": "/tasks/12345",
          "request_headers": {
            "Content-Type": "application/json"
          },
          "request_body_json": "{\"title\":\"Existing Task\",\"description\":\"Desc\",\"dueDate\":\"2026-01-10\",\"category\":\"Work\"}",
          "response_status_code": 409,
          "response_body_json": "{\"error\":\"A task with this title already exists in the selected category.\"}",
          "test_setup": {
            "given": "A task with id '12345' exists and another task with title 'Existing Task' exists in category 'Work'.",
            "when": "A PUT request is sent to /tasks/12345 with a duplicate title in the same category.",
            "then": "The API returns a 409 error indicating a duplicate title."
          },
          "implementation_id": "frontend.api.updateTask_endpoint"
        }
      ]
    }
  ]
}